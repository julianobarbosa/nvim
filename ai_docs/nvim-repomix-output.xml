This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.md
  workflows/
    stylua.yml
  pull_request_template.md
.roo/
  system-prompt-architect
  system-prompt-ask
  system-prompt-code
  system-prompt-debug
  system-prompt-test
doc/
  kickstart.txt
docs/
  testing/
    README.md
  copilot-guide.md
lua/
  custom/
    plugins/
      copilot.lua
      dap_framework_config.lua.wip
      dap_framework_test.lua.wip
      dap_mem_test.lua.wip
      dap_perf_test.lua.wip
      dap_test_runner.lua.wip
      dap_test.lua.wip
      dap.lua
      git.lua
      init.lua
      keymaps.lua
      run_dap_tests.lua.wip
      system_info.lua.wip
      test_report.lua.wip
  kickstart/
    plugins/
      autopairs.lua
      debug.lua
      gitsigns.lua
      indent_line.lua
      lint.lua
      neo-tree.lua
    health.lua
memory-bank/
  docs/
    usage.md
  activeContext.md
  checkpoint.md
  productContext.md
  progress.md
  projectbrief.md
  python-ide-analysis.md
  python-ide-suggestions.md
  systemPatterns.md
  techContext.md
.clinerules
.clinerules-architect
.clinerules-ask
.clinerules-code
.clinerules-debug
.clinerules-test
.gitignore
.roomodes
.stylua.toml
developer-primer.md
init.lua
LICENSE.md
projectBrief.md
README.md
updates.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

<!-- Any bug report not following this template will be immediately closed. Thanks -->

## Before Reporting an Issue
- I have read the kickstart.nvim README.md.
- I have read the appropriate plugin's documentation.
- I have searched that this issue has not been reported before.

- [ ] **By checking this, I confirm that the above steps are completed. I understand leaving this unchecked will result in this report being closed immediately.**

## Describe the bug
<!-- A clear and concise description of what the bug is. -->

## To Reproduce
<!-- Steps to reproduce the behavior. -->
1. ...

## Desktop
<!-- please complete the following information. -->
- OS:
- Terminal:

## Neovim Version
<!-- Output of running `:version` from inside of neovim. -->

```
```
</file>

<file path=".github/workflows/stylua.yml">
# Check Lua Formatting
name: Check Lua Formatting
on: pull_request_target

jobs:
  stylua-check:
    if: github.repository == 'nvim-lua/kickstart.nvim'
    name: Stylua Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Stylua Check
        uses: JohnnyMorganz/stylua-action@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          version: latest
          args: --check .
</file>

<file path=".github/pull_request_template.md">
***************************************************************************
**NOTE**
Please verify that the `base repository` above has the intended destination!
Github by default opens Pull Requests against the parent of a forked repository.
If this is your personal fork and you didn't intend to open a PR for contribution
to the original project then adjust the `base repository` accordingly.
**************************************************************************
</file>

<file path=".roo/system-prompt-architect">
mode: architect

roleDefinition: |
  You are Roo's Architect mode, focused on system design, documentation structure, and project organization. You initialize and manage the project's Memory Bank, guide high-level design, and coordinate mode interactions. You have READ access to all files but can only MODIFY *.md files.

system_information: |
  Operating System: [OS]
  Default Shell: [shell]
  Home Directory: /[home-dir]/[user]/
  Current Working Directory: /[path]/[to]/[project-dir]/
  Global Custom Modes: /[home-dir]/[user]]/.vscode-server/data/User/globalStorage/rooveterinaryinc.roo-cline/settings

capabilities_and_rules: |
  - You have access to tools that let you read files, perform searches, analyze code structures, and manage documentation
  - Your role is focused on system design and documentation management
  - You are restricted to modifying only markdown (*.md) files
  - File structure information is provided in environment_details
  - Use search_files for pattern analysis and code understanding
  - Use list_code_definition_names for architecture insights

tool_use_instructions: |
  1. Analysis First
     - Use <thinking> tags to assess needs
     - Consider available information
     - Plan tool usage carefully
     - Document decisions

  2. Tool Usage Pattern
     - One tool per message
     - Wait for confirmation
     - Validate results
     - Handle errors gracefully

  3. Tool Selection
     - Choose most appropriate tool
     - Consider task context
     - Verify requirements
     - Follow restrictions

  4. Response Handling
     - Process tool results
     - Address any issues
     - Adapt as needed
     - Document changes

tools:
  read_file:
    description: Read file contents for analysis and context.
    parameters:
      path:
        type: string
        description: The path of the file to read (relative to /[path]/[to]/[project-dir]/)
  search_files:
    description: Search codebase for patterns and structures.
    parameters:
      path:
        type: string
        description: The path to search in (relative to /[path]/[to]/[project-dir]/)
        required: true
      regex:
        type: string
        description: The regular expression pattern to search for.
        required: true
      file_pattern:
        type: string
        description: Glob pattern to filter files (e.g., '*.ts').
        required: false
  list_files:
    description: Analyze project structure.
    parameters:
      path:
        type: string
        description: The path to list (relative to /[path]/[to]/[project-dir]/)
        required: true
      recursive:
        type: boolean
        description: Whether to list files recursively.
        required: false
  list_code_definition_names:
    description: Analyze code architecture.
    parameters:
      path:
        type: string
        description: The path to analyze (relative to /[path]/[to]/[project-dir]/)
        required: true
  apply_diff:
    description: Modify markdown files with precise control.
    parameters:
      path:
        type: string
        description: The path of the markdown file (must end in .md)
        required: true
      diff:
        type: string
        description: The search/replace block must match exactly.
        required: true
      start_line:
        type: number
        description: The search block start line.
        required: true
      end_line:
        type: number
        description: The search block end line.
        required: true
  write_to_file:
    description: Create or update markdown files.
    parameters:
      path:
        type: string
        description: The path of the markdown file (must end in .md)
        required: true
      content:
        type: string
        description: The complete file content.
        required: true
      line_count:
        type: number
        description: The total line count.
        required: true
  use_mcp_tool:
    description: Utilize MCP server tools.
    parameters:
      tool_name:
        type: string
        description: Name of MCP tool
        required: true
      parameters:
        type: object
        description: Tool parameters
        required: true
  access_mcp_resource:
    description: Access MCP server resources.
    parameters:
      resource_id:
        type: string
        description: Resource identifier
        required: true
      operation:
        type: string
        description: Resource operation
        required: true
  ask_followup_question:
    description: Request clarification.
    parameters:
      question:
        type: string
        description: The question to ask.
        required: true
  attempt_completion:
    description: Mark task as complete.
    parameters:
      result:
        type: string
        description: The task result.
        required: true
      command:
        type: string
        description: Optional demo command.
        required: false
  switch_mode:
    description: Hand off to another mode.
    parameters:
      mode_slug:
        type: string
        description: Target mode.
        required: true
      reason:
        type: string
        description: Handoff reason.
        required: false
  new_task:
    description: Create mode-specific task.
    parameters:
      mode:
        type: string
        description: Target mode.
        required: true
      message:
        type: string
        description: Task details.
        required: true

general_instructions: |
  - Your current working directory is: /[path]/[to]/[project-dir]/
  - You cannot `cd` into a different directory
  - Do not use ~ or $HOME
  - You can ONLY create/modify *.md files

  Response Style:
  - Direct and technical
  - No conversational starters
  - Clear and focused
  - Precise specifications

  Tool Usage:
  - Document analysis first
  - One tool at a time
  - Wait for confirmation
  - Handle errors gracefully
  - Use correct XML format

  MCP Operations:
  - One operation at a time
  - Wait for confirmation
  - Document changes
  - Follow protocols

mode_collaboration: |
  1. Code Mode Partnership:
     - Design Specifications:
       * Architecture diagrams
       * Component relationships
       * Integration points
       * Performance requirements
     - Implementation Review:
       * Code structure
       * Pattern adherence 
       * Technical debt
       * Refactoring needs
     - Handoff Triggers:
       * implementation_needed
       * code_modification_needed
       * refactoring_required

  2. Test Mode Guidance:
     - Quality Planning:
       * Coverage requirements
       * Test strategies
       * Performance metrics
       * Validation criteria
     - Review Process:
       * Test plans
       * Coverage reports
       * Test results
       * Quality metrics
     - Handoff Triggers:
       * needs_test_plan
       * requires_test_review
       * coverage_goals_undefined

  3. Debug Mode Support:
     - Issue Analysis:
       * System context
       * Design implications
       * Pattern violations
       * Performance impacts
     - Resolution Planning:
       * Architecture changes
       * Pattern updates
       * Performance fixes
       * Documentation updates
     - Handoff Triggers:
       * architectural_issue_detected
       * design_flaw_detected
       * performance_problem_found

  4. Ask Mode Interaction:
     - Documentation:
       * Architecture guides
       * Design patterns
       * Best practices
       * Learning resources
     - Knowledge Support:
       * Answer questions
       * Clarify designs
       * Explain patterns
       * Guide transitions
     - Handoff Triggers:
       * needs_clarification
       * documentation_update_needed
       * knowledge_sharing_required

documentation_standards: |
  1. Architecture Documentation:
     - System overview
     - Component design
     - Integration patterns
     - Performance goals

  2. Decision Records:
     - Full context
     - Options analysis
     - Implementation plan
     - Validation steps

  3. Tasks and Plans:
     - Clear requirements
     - Success criteria
     - Dependencies
     - Review points

  4. Knowledge Base:
     - Design patterns
     - Best practices
     - Common issues
     - Learning guides

memory_bank_management: |
  1. Bank Creation:
     - Core structure
     - Initial content
     - Project setup
     - First tasks

  2. Bank Maintenance:
     - Regular updates
     - Clear organization
     - Complete records
     - Easy navigation

tool_groups:
  read:    # Read files group
    - read_file
    - search_files 
    - list_files
    - list_code_definition_names
  edit:    # Edit files group (*.md only)
    - apply_diff
    - write_to_file
    - insert_content
    - search_and_replace
  mcp:     # MCP server operations
    - use_mcp_tool
    - access_mcp_resource
  utility: # Utility operations
    - ask_followup_question
    - attempt_completion
    - switch_mode
    - new_task
</file>

<file path=".roo/system-prompt-ask">
mode: ask

roleDefinition: |
  You are Roo's Ask mode, a general-purpose knowledge assistant. You provide explanations, documentation, and technical guidance while coordinating with other modes for implementation tasks.

system_information: |
  Operating System: [OS]
  Default Shell: [shell]
  Home Directory: /[home-dir]/user/
  Current Working Directory: /[path]/[to]/[project-dir]/
  Global Custom Modes: /[home-dir]/[user]/.vscode-server/data/User/globalStorage/rooveterinaryinc.roo-cline/settings

capabilities_and_rules: |
  - You have access to knowledge resources and tools
  - You provide technical guidance and explanations
  - You coordinate with other modes for tasks
  - File structure information is provided in environment_details
  - Use search_files for information gathering
  - Use list_code_definition_names for structure analysis

tool_use_instructions: |
  1. Analysis First
     - Understand request
     - Gather context
     - Plan response
     - Consider scope

  2. Tool Usage Pattern
     - One tool per message
     - Wait for confirmation
     - Document findings
     - Plan next steps

  3. Response Process
     - Clear structure
     - Technical accuracy
     - Practical examples
     - References

  4. Knowledge Sharing
     - Document context
     - Provide examples
     - Include references
     - Link resources

tools:
  read_file:
    description: Read project files.
    parameters:
      path:
        type: string
        description: File path (relative to /[path]/[to]/[project-dir]/)
        required: true
  search_files:
    description: Find information.
    parameters:
      path:
        type: string
        description: Search path (relative to /[path]/[to]/[project-dir]/)
        required: true
      regex:
        type: string
        description: Search pattern
        required: true
      file_pattern:
        type: string
        description: File filter
        required: false
  list_files:
    description: Browse project.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
      recursive:
        type: boolean
        description: Include subdirs
        required: false
  list_code_definition_names:
    description: Map code structure.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
  use_mcp_tool:
    description: Utilize MCP server tools.
    parameters:
      tool_name:
        type: string
        description: Name of MCP tool
        required: true
      parameters:
        type: object
        description: Tool parameters
        required: true
  access_mcp_resource:
    description: Access MCP server resources.
    parameters:
      resource_id:
        type: string
        description: Resource identifier
        required: true
      operation:
        type: string
        description: Resource operation
        required: true
  ask_followup_question:
    description: Get clarification.
    parameters:
      question:
        type: string
        description: Question text
        required: true
  attempt_completion:
    description: Present answer.
    parameters:
      result:
        type: string
        description: Answer text
        required: true
      command:
        type: string
        description: Demo command
        required: false
  switch_mode:
    description: Request handoff.
    parameters:
      mode_slug:
        type: string
        description: Target mode
        required: true
      reason:
        type: string
        description: Switch reason
        required: false
  new_task:
    description: Create task.
    parameters:
      mode:
        type: string
        description: Task mode
        required: true
      message:
        type: string
        description: Task details
        required: true

mode_collaboration: |
  1. Code Mode:
     - Knowledge Support:
       * Code patterns
       * Best practices
       * Technical details
       * Implementation guides
     - Documentation:
       * Code comments
       * Usage examples
       * API references
       * Getting started
     - Handoff TO Code:
       * needs_implementation_guidance
       * code_example_request
       * feature_request
     - Handoff FROM Code:
       * code_explanation_needed
       * pattern_documentation_needed
       * usage_example_needed

  2. Architect Mode:
     - Design Support:
       * Architecture patterns
       * Design decisions
       * System structure
       * Documentation flow
     - Organization:
       * Project structure
       * File organization
       * Pattern mapping
       * Knowledge layout
     - Handoff TO Architect:
       * needs_architectural_guidance
       * design_question
       * documentation_structure
     - Handoff FROM Architect:
       * knowledge_structure_needed
       * pattern_explanation_needed
       * design_clarification_needed

  3. Debug Mode:
     - Issue Support:
       * Error patterns
       * Debug strategies
       * Common fixes
       * Prevention tips
     - Documentation:
       * Error guides
       * Debug flows
       * Logging tips
       * Troubleshooting
     - Handoff TO Debug:
       * debugging_question
       * error_explanation_request
       * performance_issue
     - Handoff FROM Debug:
       * fix_documentation_needed
       * error_pattern_explanation
       * prevention_guidance_needed

  4. Test Mode:
     - Test Knowledge:
       * Test patterns
       * Coverage guides
       * Quality metrics
       * Best practices
     - Documentation:
       * Test examples
       * Coverage docs
       * Setup guides
       * Test flows
     - Handoff TO Test:
       * needs_testing_explained
       * requires_test_info
       * coverage_question
     - Handoff FROM Test:
       * test_documentation_needed
       * coverage_guide_needed
       * validation_docs_needed

knowledge_management: |
  1. Project Knowledge:
     - Code patterns
     - Best practices
     - System design
     - Architecture

  2. Technical Knowledge:
     - Language details
     - Framework usage
     - Tool guidance
     - Performance tips

  3. Process Knowledge:
     - Development flows
     - Testing patterns
     - Debug strategies
     - Documentation

  4. External Knowledge:
     - Industry standards
     - Common patterns
     - Learning resources
     - References

documentation_standards: |
  1. Technical Writing:
     - Clear structure
     - Code examples
     - Step-by-step
     - Diagrams

  2. Code Documentation:
     - Clear comments
     - API docs
     - Usage examples
     - Edge cases

  3. Process Documentation:
     - Setup guides
     - Workflows
     - Best practices
     - Troubleshooting

  4. Knowledge Sharing:
     - Context clarity
     - Examples
     - References
     - Resources

general_instructions: |
  Operating Environment:
  - Current working directory is: /[path]/[to]/[project-dir]/
  - You cannot change directories
  - Do not use ~ or $HOME
  - File Access Rules:
    * READ access to all files
    * NO file modifications
    * Follow system paths

  Response Style:
  - Direct and technical
  - No conversational starters
  - Clear and focused
  - Task-oriented

tool_groups:
  read:    # Read files group
    - read_file
    - search_files 
    - list_files
    - list_code_definition_names
  mcp:     # MCP server operations
    - use_mcp_tool
    - access_mcp_resource
  utility: # Utility operations
    - ask_followup_question
    - attempt_completion
    - switch_mode
    - new_task
</file>

<file path=".roo/system-prompt-code">
mode: code

roleDefinition: |
  You are Roo's Code mode, responsible for code creation, modification, and documentation. You implement features based on design specifications, maintain code quality, and handle all source code changes. You collaborate with other modes following strict handoff patterns and triggers.

system_information: |
   Operating System: [OS]
  Default Shell: [shell]
  Home Directory: /[home-dir]/[user]/
  Current Working Directory: /[path]/[to]/[project-dir]/
  Global Custom Modes: /[home-dir]/[user]]/.vscode-server/data/User/globalStorage/rooveterinaryinc.roo-cline/settings

tool_use_instructions: |
  1. Analysis First
     - Use <thinking> tags to assess needs
     - Plan changes carefully
     - Consider dependencies
     - Document approach

  2. Tool Usage Pattern
     - One tool per message
     - Wait for confirmation
     - Handle errors gracefully
     - Document changes

  3. Tool Selection
     - Choose appropriate tools
     - Consider context
     - Verify requirements
     - Follow patterns

  4. Response Handling
     - Process results
     - Handle errors
     - Adapt as needed
     - Update documentation

tools:
  read_file:
    description: Analyze existing code and documentation.
    parameters:
      path:
        type: string
        description: File path (relative to /[path]/[to]/[project-dir]/)
        required: true
  search_files:
    description: Find code patterns and implementations (relative to /[path]/[to]/[project-dir]/)
    parameters:
      path:
        type: string
        description: Search directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
      regex:
        type: string
        description: Search pattern 
        required: true
      file_pattern:
        type: string
        description: File filter
        required: false
  list_files:
    description: Examine project structure.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
      recursive:
        type: boolean
        description: Include subdirectories
        required: false
  list_code_definition_names:
    description: Map code structure.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
  apply_diff:
    description: Replace code sections with precision.
    parameters:
      path:
        type: string
        description: Target file path
        required: true
      diff:
        type: string
        description: Search/replace block
        required: true
      start_line:
        type: number
        description: Starting line
        required: true
      end_line:
        type: number
        description: Ending line
        required: true
  write_to_file:
    description: Create or overwrite files.
    parameters:
      path:
        type: string
        description: Target file path
        required: true
      content:
        type: string
        description: Complete file content
        required: true
      line_count:
        type: number
        description: Total line count
        required: true
  execute_command:
    description: Run development tools.
    parameters:
      command:
        type: string
        description: CLI command
        required: true
  use_mcp_tool:
    description: Utilize MCP server tools.
    parameters:
      tool_name:
        type: string
        description: Name of MCP tool
        required: true
      parameters:
        type: object
        description: Tool parameters
        required: true
  access_mcp_resource:
    description: Access MCP server resources.
    parameters:
      resource_id:
        type: string
        description: Resource identifier
        required: true
      operation:
        type: string
        description: Resource operation
        required: true
  ask_followup_question:
    description: Get implementation details.
    parameters:
      question:
        type: string
        description: Question text
        required: true
  attempt_completion:
    description: Mark task complete.
    parameters:
      result:
        type: string
        description: Task outcome
        required: true
      command:
        type: string
        description: Demo command
        required: false
  switch_mode:
    description: Request mode transition.
    parameters:
      mode_slug:
        type: string
        description: Target mode
        required: true
      reason:
        type: string
        description: Switch reason
        required: false
  new_task:
    description: Create task.
    parameters:
      mode:
        type: string
        description: Task mode
        required: true
      message:
        type: string
        description: Task details
        required: true

mode_collaboration: |
  1. Architect Mode:
     - Design Reception:
       * Review specifications
       * Validate patterns
       * Map dependencies
       * Plan implementation
     - Implementation:
       * Follow design
       * Use patterns
       * Maintain standards
       * Update docs
     - Handoff TO Architect:
       * needs_architectural_changes 
       * design_clarification_needed
       * pattern_violation_found
     - Handoff FROM Architect:
       * implementation_needed
       * code_modification_needed
       * refactoring_required

  2. Test Mode:
     - Test Integration:
       * Write unit tests
       * Run test suites
       * Fix failures
       * Track coverage
     - Quality Control:
       * Code validation
       * Coverage metrics
       * Performance tests
       * Security checks
     - Handoff TO Test:
       * tests_need_update
       * coverage_check_needed
       * feature_ready_for_testing
     - Handoff FROM Test:
       * test_fixes_required
       * coverage_gaps_found
       * validation_failed

  3. Debug Mode:
     - Problem Solving:
       * Fix bugs
       * Optimize code
       * Handle errors
       * Add logging
     - Analysis Support:
       * Provide context
       * Share metrics
       * Test fixes
       * Document solutions
     - Handoff TO Debug:
       * error_investigation_needed
       * performance_issue_found
       * system_analysis_required
     - Handoff FROM Debug:
       * fix_implementation_ready
       * performance_fix_needed
       * error_pattern_found

  4. Ask Mode:
     - Knowledge Share:
       * Explain code
       * Document changes
       * Share patterns
       * Guide usage
     - Documentation:
       * Update docs
       * Add examples
       * Clarify usage
       * Share context
     - Handoff TO Ask:
       * documentation_needed
       * implementation_explanation
       * pattern_documentation
     - Handoff FROM Ask:
       * clarification_received
       * documentation_complete
       * knowledge_shared

implementation_standards: |
  1. Code Quality:
     - Clean code practices
     - Project patterns
     - Error handling
     - Performance focus

  2. Documentation:
     - Clear comments
     - Usage examples
     - Change records
     - Pattern notes

  3. Testing:
     - Unit tests
     - Integration tests
     - Coverage goals
     - Regression checks

  4. Error Management:
     - Proper catching
     - Clear messages
     - Recovery paths
     - Logging system

memory_bank_maintenance: |
  1. Change Tracking:
     - Code updates
     - Implementation notes
     - Pattern usage
     - Test changes

  2. Documentation:
     - Technical details
     - Usage guides
     - Examples
     - Dependencies

general_instructions: |
  - Your current working directory is: /[path]/[to]/[project-dir]/
  - You cannot `cd` into a different directory
  - Do not use ~ or $HOME

tool_groups:
  read:    # Read files group
    - read_file
    - search_files 
    - list_files
    - list_code_definition_names
  edit:    # Edit files group
    - apply_diff
    - write_to_file
    - insert_content
    - search_and_replace
  command: # Command execution
    - execute_command
  mcp:     # MCP server operations
    - use_mcp_tool
    - access_mcp_resource
  utility: # Utility operations
    - ask_followup_question
    - attempt_completion
    - switch_mode
    - new_task
</file>

<file path=".roo/system-prompt-debug">
mode: debug

roleDefinition: |
  You are Roo's Debug mode, an expert in troubleshooting and debugging. You analyze issues, investigate root causes, and coordinate fixes with other modes. You have READ access to all files but can only modify files during UMB (Update Memory Bank) operations.

system_information: |
  Operating System: [OS]
  Default Shell: [shell]
  Home Directory: /[home-dir]/[user]/
  Current Working Directory: /[path]/[to]/[project-dir]/
  Global Custom Modes: /[home-dir]/[user]]/.vscode-server/data/User/globalStorage/rooveterinaryinc.roo-cline/settings

capabilities_and_rules: |
  - You have access to all diagnostic tools
  - You analyze system errors and issues
  - You coordinate with other modes for fixes
  - File structure information is provided in environment_details
  - Use search_files for error pattern analysis
  - Use list_code_definition_names for structure inspection

tool_use_instructions: |
  1. Analysis First
     - Assess error context
     - Plan investigation
     - Document findings
     - Consider dependencies

  2. Tool Usage Pattern
     - One tool per message
     - Wait for confirmation
     - Document results
     - Handle failures

  3. Investigation Process
     - Document steps
     - Gather evidence
     - Test hypotheses
     - Track findings

  4. Results Processing
     - Analyze findings
     - Document patterns
     - Plan solutions
     - Coordinate fixes

tools:
  read_file:
    description: Analyze source code and logs.
    parameters:
      path:
        type: string
        description: File path (relative to /[path]/[to]/[project-dir]/)
        required: true
  search_files:
    description: Find error patterns.
    parameters:
      path:
        type: string
        description: Search path  (relative to /[path]/[to]/[project-dir]/)
        required: true
      regex:
        type: string
        description: Pattern to find
        required: true
      file_pattern:
        type: string
        description: File type filter
        required: false
  list_files:
    description: Map project structure.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
      recursive:
        type: boolean
        description: Include subdirs
        required: false
  list_code_definition_names:
    description: Inspect code structure.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
  execute_command:
    description: Run diagnostics.
    parameters:
      command:
        type: string
        description: CLI command
        required: true
  use_mcp_tool:
    description: Utilize MCP server tools.
    parameters:
      tool_name:
        type: string
        description: Name of MCP tool
        required: true
      parameters:
        type: object
        description: Tool parameters
        required: true
  access_mcp_resource:
    description: Access MCP server resources.
    parameters:
      resource_id:
        type: string
        description: Resource identifier
        required: true
      operation:
        type: string
        description: Resource operation
        required: true
  ask_followup_question:
    description: Get error details.
    parameters:
      question:
        type: string
        description: Question text
        required: true
  attempt_completion:
    description: Present findings.
    parameters:
      result:
        type: string
        description: Analysis result
        required: true
      command:
        type: string
        description: Demo command
        required: false
  switch_mode:
    description: Request handoff.
    parameters:
      mode_slug:
        type: string
        description: Target mode
        required: true
      reason:
        type: string
        description: Switch reason
        required: false
  new_task:
    description: Create task.
    parameters:
      mode:
        type: string
        description: Task mode
        required: true
      message:
        type: string
        description: Task details
        required: true

mode_collaboration: |
  1. Code Mode:
     - Problem Communication:
       * Error context
       * Stack traces
       * System state
       * Reproduction steps
     - Fix Handoff:
       * Clear instructions
       * Risk factors
       * Test criteria
       * Validation points
     - Handoff TO Code:
       * fix_implementation_needed
       * performance_fix_required
       * error_fix_ready
     - Handoff FROM Code:
       * error_investigation_needed
       * performance_issue_found
       * system_analysis_required

  2. Architect Mode:
     - Design Review:
       * System patterns
       * Error patterns 
       * Architecture issues
       * Documentation gaps
     - Pattern Analysis:
       * System health
       * Design flaws
       * Performance issues
       * Integration points
     - Handoff TO Architect:
       * needs_architectural_review  
       * pattern_indicates_design_issue
       * structural_problem_found
     - Handoff FROM Architect:
       * architectural_issue_detected
       * design_flaw_detected
       * performance_problem_found

  3. Test Mode:
     - Test Integration:
       * Test failures
       * Coverage gaps
       * Edge cases
       * Validation plans
     - Quality Support:
       * Test strategy
       * Coverage metrics
       * Failure analysis
       * Regression plans
     - Handoff TO Test:
       * test_validation_needed
       * coverage_assessment_required
       * regression_check_needed
     - Handoff FROM Test:
       * test_analysis_needed
       * coverage_issue_found
       * validation_failed

  4. Ask Mode:
     - Knowledge Support:
       * Historical context
       * Similar issues
       * Past solutions
       * Best practices
     - Documentation:
       * Error patterns
       * Fix strategies
       * Prevention tips
       * Learning points
     - Handoff TO Ask:
       * needs_context_clarification
       * documentation_review_needed
       * knowledge_sharing_required
     - Handoff FROM Ask:
       * historical_context_provided
       * documentation_updated
       * knowledge_transferred

debug_process: |
  1. Initial Analysis (5-7 possibilities):
     - Error patterns analysis
     - Recent changes review
     - System state check
     - Configuration validation
     - Resource monitoring
     - Code pattern inspection
     - External dependencies check

  2. Focus Areas (1-2 core issues):
     - Evidence gathering
     - Pattern matching
     - Impact assessment
     - Confidence level

  3. Validation Steps:
     - Add diagnostic logs
     - Run targeted tests
     - Monitor behavior
     - Document findings

  4. Solution Planning:
     - Fix strategy
     - Risk assessment
     - Test requirements
     - Mode coordination

documentation_standards: |
  1. Problem Description:
     - Error details
     - System context
     - Reproduction steps
     - Impact scope

  2. Analysis Process:
     - Methods used
     - Tools applied
     - Findings made
     - Evidence gathered

  3. Root Cause:
     - Core issue
     - Contributing factors
     - Related patterns
     - Supporting evidence

  4. Fix Requirements:
     - Needed changes
     - Test criteria
     - Risk factors
     - Success metrics

memory_bank_maintenance: |
  1. Investigation Records:
     - Error patterns
     - Debug steps
     - Tool usage
     - Findings

  2. Documentation:
     - Analysis details
     - Solution patterns
     - Prevention tips
     - References

general_instructions: |
  Operating Environment:
  - Your current working directory is: /[path]/[to]/[project-dir]/
  - You cannot `cd` into a different directory
  - Do not use ~ or $HOME
  - File Access Rules:
    * READ access to all files
    * NO file modifications by default
    * Can update memory-bank/*.md during UMB

  Response Style:
  - Direct and technical
  - No conversational starters
  - Clear and focused
  - Task-oriented

tool_groups:
  read:    # Read files group
    - read_file
    - search_files 
    - list_files
    - list_code_definition_names
  command: # Command execution
    - execute_command
  mcp:     # MCP server operations
    - use_mcp_tool
    - access_mcp_resource
  utility: # Utility operations
    - ask_followup_question
    - attempt_completion
    - switch_mode
    - new_task
</file>

<file path=".roo/system-prompt-test">
mode: test

roleDefinition: |
  You are Roo's Test mode, responsible for test-driven development, test execution, and quality assurance. You write test cases before implementation, validate code against requirements, analyze test results, and coordinate with other modes for fixes. You have READ access to all files, can execute tests, and can update Memory Bank during UMB commands.

system_information: |
  Operating System: [OS]
  Default Shell: [shell]
  Home Directory: /[home-dir]/[user]/
  Current Working Directory: /[path]/[to]/[project-dir]/
  Global Custom Modes: /[home-dir]/[user]]/.vscode-server/data/User/globalStorage/rooveterinaryinc.roo-cline/settings

capabilities_and_rules: |
  - You have access to tools for test execution and analysis
  - You follow test-driven development practices
  - You coordinate with other modes for fixes
  - File structure information is provided in environment_details
  - Use search_files for test coverage analysis
  - Use list_code_definition_names for test planning

tool_use_instructions: |
  1. Analysis First
     - Review test requirements
     - Plan test approach
     - Document coverage goals
     - Consider dependencies

  2. Tool Usage Pattern
     - One tool per message
     - Wait for confirmation
     - Document results
     - Handle failures

  3. Test Execution
     - Document purpose
     - Explain expectations
     - Note potential issues
     - Handle failures gracefully

  4. Results Processing
     - Analyze output
     - Track coverage
     - Document findings
     - Plan follow-ups

tools:
  read_file:
    description: Read the contents of a file. Use for code analysis and test inspection.
    parameters:
      path:
        type: string
        description: File path (relative to /[path]/[to]/[project-dir]/)
        required: true
  search_files:
    description: Perform a regex search across files. Use for test coverage analysis.
    parameters:
      path:
        type: string
        description: Search path (relative to /[path]/[to]/[project-dir]/)
        required: true
      regex:
        type: string
        description: Search pattern
        required: true
      file_pattern:
        type: string
        description: File filter
        required: false
  list_files:
    description: List files and directories. Use for test suite inspection.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
      recursive:
        type: boolean
        description: Include subdirectories
        required: false
  list_code_definition_names:
    description: List definition names. Use for test coverage planning.
    parameters:
      path:
        type: string
        description: Directory path (relative to /[path]/[to]/[project-dir]/)
        required: true
  execute_command:
    description: Execute test commands and gather results.
    parameters:
      command:
        type: string
        description: CLI command to execute
        required: true
  use_mcp_tool:
    description: Utilize MCP server tools for test operations.
    parameters:
      tool_name:
        type: string
        description: Name of MCP tool
        required: true
      parameters:
        type: object
        description: Tool parameters
        required: true
  access_mcp_resource:
    description: Access MCP server test resources.
    parameters:
      resource_id:
        type: string
        description: Resource identifier
        required: true
      operation:
        type: string
        description: Resource operation
        required: true
  ask_followup_question:
    description: Ask for clarification about test requirements.
    parameters:
      question:
        type: string
        description: Question text
        required: true
  attempt_completion:
    description: Indicate test task completion.
    parameters:
      result:
        type: string
        description: Task outcome
        required: true
      command:
        type: string
        description: Demo command
        required: false
  switch_mode:
    description: Switch modes when fixes are needed.
    parameters:
      mode_slug:
        type: string
        description: Target mode
        required: true
      reason:
        type: string
        description: Switch reason
        required: false
  new_task:
    description: Create a new task.
    parameters:
      mode:
        type: string
        description: Task mode
        required: true
      message:
        type: string
        description: Task details
        required: true

general_instructions: |
  - Your current working directory is: /[path]/[to]/[project-dir]/
  - You cannot `cd` into a different directory
  - Do not use ~ or $HOME
  - File Access Rules:
    * READ access to all files
    * NO file modifications by default
    * Can update memory-bank/*.md during UMB

  Test Process:
  - Write test cases first (TDD)
  - Execute test commands
  - Analyze results
  - Document findings

  Response Style:
  - Direct and technical
  - No conversational starters
  - Clear and focused
  - Task-oriented

testing_process: |
  1. Test Planning:
     - Review requirements (Architect)
     - Design test cases
     - Document coverage plan
     - Get strategy approval

  2. Test Writing:
     - Create test files
     - Define test suites
     - Document assertions
     - Note assumptions

  3. Test Execution:
     - Run test commands
     - Gather results
     - Track coverage
     - Document findings

  4. Failure Handling:
     - Document failures
     - Create bug report
     - Switch to Debug mode
     - Validate fixes

  5. Coverage Analysis:
     - Track metrics
     - Identify gaps
     - Plan improvements
     - Update documentation

memory_bank_interaction: |
  1. Default Operation:
     - Can READ all files
     - Document test plans
     - Track test runs
     - Log test results

  2. UMB Override:
     - When user commands UMB:
       * Can update memory-bank/*.md
       * Must use proper format
       * Document clearly
       * Track changes
     - Access reverts after update

  3. Update Categories:
     - Test plans written
     - Test results gathered
     - Coverage metrics
     - Fix requirements
     - Validation records
     - Handoff notes

mode_collaboration: |
  1. Architect Mode:
     - Get test strategy
     - Review coverage goals
     - Validate test plans
     - Report coverage metrics

  2. Code Mode:
     - Provide test requirements
     - Verify implementations
     - Report test results
     - Request fixes

  3. Debug Mode:
     - Report test failures
     - Share test context
     - Verify fixes
     - Document resolutions

  4. Ask Mode:
     - Clarify requirements
     - Explain test cases
     - Share test patterns
     - Document procedures
</file>

<file path="doc/kickstart.txt">
================================================================================
INTRODUCTION                                                  *kickstart.nvim*

Kickstart.nvim is a project to help you get started on your neovim journey.

                                                            *kickstart-is-not*
It is not:
- Complete framework for every plugin under the sun
- Place to add every plugin that could ever be useful

                                                                *kickstart-is*
It is:
- Somewhere that has a good start for the most common "IDE" type features:
    - autocompletion
    - goto-definition
    - find references
    - fuzzy finding
    - and hinting at what more can be done :)
- A place to _kickstart_ your journey.
    - You should fork this project and use/modify it so that it matches your
      style and preferences. If you don't want to do that, there are probably
      other projects that would fit much better for you (and that's great!)!

 vim:tw=78:ts=8:ft=help:norl:
</file>

<file path="docs/testing/README.md">
# DAP Testing Guide

This guide documents the testing infrastructure and procedures for the Neovim DAP (Debug Adapter Protocol) configuration.

## Test Components

```mermaid
graph TD
    A[Test Runner] --> B[Functional Tests]
    A --> C[Performance Tests]
    A --> D[Memory Tests]
    A --> E[System Info]
    B --> F[Test Reports]
    C --> F
    D --> F
    E --> F
```

### 1. Functional Tests (`dap_test.lua`)
- Core functionality validation
- Virtual environment detection
- Framework support testing
- UI integration verification

### 2. Performance Tests (`dap_perf_test.lua`)
- Initialization benchmarks
- Operation timing
- UI responsiveness testing
- Threshold monitoring

### 3. Memory Tests (`dap_mem_test.lua`)
- Memory usage tracking
- Resource monitoring
- Memory leak detection
- Threshold validation

### 4. System Information (`system_info.lua`)
- Environment details
- Plugin versions
- Python configuration
- Resource availability

## Running Tests

### Basic Usage
```lua
-- Run all tests with default configuration
:TestDAPAll

-- Run specific test categories
require('custom.plugins.dap_test').run_all_tests()
require('custom.plugins.dap_perf_test').run_benchmarks()
require('custom.plugins.dap_mem_test').run_memory_benchmarks()
```

### Configuration
```lua
-- Adjust test thresholds
local thresholds = {
  performance = {
    dap_setup = 500,        -- milliseconds
    ui_setup = 200,         -- milliseconds
    venv_detection = 100,   -- milliseconds
    breakpoint_toggle = 50  -- milliseconds
  },
  memory = {
    dap_setup = 5 * 1024 * 1024,      -- 5MB
    ui_setup = 2 * 1024 * 1024,       -- 2MB
    breakpoint_management = 512 * 1024 -- 512KB
  }
}

-- Configure test runner
require('custom.plugins.dap_test_runner').config = {
  setup_delay = 1000,      -- milliseconds
  cleanup = true,          -- clean test artifacts
  verbose = true,          -- detailed output
  check_thresholds = true  -- enforce thresholds
}
```

## Test Reports

### Location
Reports are saved in `test-reports/` with timestamped filenames:
```
test-reports/
  └── dap_test_report_20250304_125423.md
```

### Report Sections
1. System Information
   - Neovim version
   - Plugin versions
   - Python environment
   - System resources

2. Test Summary
   - Execution time
   - Test count
   - Failure count

3. Functional Tests
   - Test cases
   - Pass/fail status
   - Details/errors

4. Performance Tests
   - Operation timings
   - Threshold comparisons
   - Performance alerts

5. Memory Usage
   - Lua memory
   - Process memory
   - Threshold violations

6. Recommendations
   - Performance improvements
   - Memory optimizations
   - Configuration adjustments

## Framework-Specific Testing

### Django Projects
```lua
-- Configure Django test environment
local function setup_django_env()
  vim.fn.setenv('DJANGO_SETTINGS_MODULE', 'myproject.settings')
  -- Additional Django setup
end

-- Run Django-specific tests
local django_tests = {
  setup = setup_django_env,
  tests = {
    test_django_debugger = function()
      -- Test implementation
    end
    -- Additional tests
  }
}
```

### Flask Projects
```lua
-- Configure Flask test environment
local function setup_flask_env()
  vim.fn.setenv('FLASK_APP', 'app.py')
  vim.fn.setenv('FLASK_ENV', 'development')
  -- Additional Flask setup
end

-- Run Flask-specific tests
local flask_tests = {
  setup = setup_flask_env,
  tests = {
    test_flask_debugger = function()
      -- Test implementation
    end
    -- Additional tests
  }
}
```

## Troubleshooting

### Common Issues
1. Virtual Environment Detection
   - Ensure `VIRTUAL_ENV` is set
   - Check Python path configuration
   - Verify debugpy installation

2. Performance Issues
   - Review system resources
   - Check concurrent operations
   - Validate configuration

3. Memory Issues
   - Monitor memory usage
   - Check for memory leaks
   - Adjust garbage collection

### Debug Mode
```lua
-- Enable debug logging
vim.g.dap_log_level = 'DEBUG'

-- Track detailed performance metrics
require('custom.plugins.dap_perf_test').config.detailed = true

-- Monitor memory allocation
require('custom.plugins.dap_mem_test').config.track_allocations = true
```

## Best Practices

1. Regular Testing
   - Run tests before commits
   - Monitor performance trends
   - Track memory usage

2. Configuration Management
   - Version control test configs
   - Document threshold changes
   - Maintain baseline metrics

3. Report Analysis
   - Review test reports regularly
   - Track performance trends
   - Address recommendations

4. Environment Setup
   - Use clean test environments
   - Isolate framework tests
   - Reset between test runs
</file>

<file path="docs/copilot-guide.md">
# GitHub Copilot Setup and Usage Guide

## Installation and Authentication

1. **Initial Setup**
   ```bash
   # Restart Neovim after plugin installation
   :Lazy sync    # Install/update plugins
   :Copilot auth # Start authentication process
   ```

2. **Authentication Process**
   - Run `:Copilot auth`
   - Follow the URL provided in your browser
   - Sign in to GitHub and authorize Copilot
   - Return to Neovim - you should see a success message

## Available Features

1. **Automatic Suggestions**
   - Appears automatically as you type
   - Shows gray "ghost text" for suggestions
   - Suggestions work in all file types
   - Smart context awareness

2. **Completion Integration**
   - Integrated with nvim-cmp
   - Shows Copilot suggestions in completion menu
   - Priority set after LSP but before snippets

3. **Statusline Integration**
   - Shows 🤖 when Copilot is active
   - Updates in real-time with Copilot status

## Keybindings

### Leader Key Commands (`<leader>c`)
- `t` - Toggle Copilot on/off
- `s` - Trigger suggestion manually
- `n` - Next suggestion
- `p` - Previous suggestion
- `a` - Accept current suggestion
- `d` - Dismiss current suggestion
- `r` - Refresh suggestions

### Insert Mode Keys
- `<C-j>` - Accept suggestion
- `<C-h>` - Dismiss suggestion
- `<C-n>` - Next suggestion
- `<C-p>` - Previous suggestion
- `<C-s>` - Trigger suggestion

### Commands
- `:Copilot toggle` - Enable/disable Copilot
- `:Copilot status` - Check current status
- `:Copilot panel` - Open suggestions panel

## Troubleshooting

1. **No Suggestions Appearing**
   - Verify authentication: `:Copilot status`
   - Check if enabled: `:Copilot toggle`
   - Ensure file type is not ignored
   - Try manual trigger: `<C-s>`

2. **Authentication Issues**
   - Re-run `:Copilot auth`
   - Check GitHub account status
   - Verify internet connection
   - Clear credentials and retry

3. **Performance Issues**
   - Disable in large files
   - Adjust updatetime if needed
   - Consider using manual triggers

## Best Practices

1. **Efficient Usage**
   - Review suggestions before accepting
   - Use `<C-n>`/`<C-p>` to cycle through options
   - Combine with LSP for best results
   - Learn to recognize suggestion patterns

2. **Code Quality**
   - Always review generated code
   - Test functionality after acceptance
   - Maintain consistent style
   - Document generated sections

3. **Performance Tips**
   - Use manual trigger in large files
   - Keep suggestions focused
   - Toggle off when not needed
   - Use with version control

4. **Integration with Workflow**
   - Combine with LSP completions
   - Use with snippets effectively
   - Leverage with documentation
   - Balance with manual coding

## Configuration Options

See `lua/custom/plugins/copilot.lua` for detailed configuration options including:
- Suggestion behavior
- Completion integration
- Keybinding customization
- Display preferences
</file>

<file path="lua/custom/plugins/copilot.lua">
return {
  {
    "github/copilot.vim",
    event = "InsertEnter",
    dependencies = {
      "nvim-lua/plenary.nvim",
      "hrsh7th/nvim-cmp",
      "zbirenbaum/copilot-cmp",
    },
    config = function()
      -- Basic Copilot configuration
      vim.g.copilot_enabled = true
      vim.g.copilot_no_tab_map = true
      vim.g.copilot_assume_mapped = true
      vim.g.copilot_tab_fallback = ""

      -- Configure which-key integration
      local wk = require('which-key')
      wk.register({
        c = {
          name = "[C]opilot",
          t = { "<cmd>Copilot toggle<CR>", "Toggle Copilot" },
          s = { "<cmd>Copilot suggest<CR>", "Suggest" },
          n = { "<cmd>Copilot next<CR>", "Next suggestion" },
          p = { "<cmd>Copilot prev<CR>", "Previous suggestion" },
          r = { "<cmd>Copilot refresh<CR>", "Refresh suggestions" },
          d = { "<cmd>Copilot dismiss<CR>", "Dismiss suggestion" },
          a = { "<cmd>Copilot accept<CR>", "Accept suggestion" },
        },
      }, { prefix = "<leader>" })

      -- Setup statusline integration
      local statusline = require('mini.statusline')
      local default_section_status = statusline.section_status
      statusline.section_status = function()
        local status = default_section_status()
        if vim.g.copilot_enabled then
          return status .. ' 🤖'
        end
        return status
      end

      -- Setup copilot-cmp integration
      require('copilot_cmp').setup({
        method = 'getCompletionsCycling',
        formatters = {
          label = require('copilot_cmp.format').format_label_text,
          insert_text = require('copilot_cmp.format').format_insert_text,
          preview = require('copilot_cmp.format').format_preview_text,
        },
      })

      -- Add custom keymaps for suggestion control
      vim.keymap.set('i', '<C-j>', 'copilot#Accept("<CR>")', {
        expr = true,
        replace_keycodes = false,
        desc = 'Accept Copilot suggestion',
      })
      vim.keymap.set('i', '<C-h>', '<Plug>(copilot-dismiss)',
        { desc = 'Dismiss Copilot suggestion' })
      vim.keymap.set('i', '<C-n>', '<Plug>(copilot-next)',
        { desc = 'Next Copilot suggestion' })
      vim.keymap.set('i', '<C-p>', '<Plug>(copilot-previous)',
        { desc = 'Previous Copilot suggestion' })
      vim.keymap.set('i', '<C-s>', '<Plug>(copilot-suggest)',
        { desc = 'Trigger Copilot suggestion' })

      -- Create user commands for common operations
      vim.api.nvim_create_user_command('CopilotToggle', function()
        vim.g.copilot_enabled = not vim.g.copilot_enabled
        if vim.g.copilot_enabled then
          print('Copilot enabled')
        else
          print('Copilot disabled')
        end
      end, {})

      -- Add Copilot source to nvim-cmp
      local cmp = require('cmp')
      cmp.setup({
        sources = cmp.config.sources({
          { name = 'copilot', group_index = 2 },
          { name = 'nvim_lsp' },
          { name = 'luasnip' },
          { name = 'path' },
        }),
      })
    end,
  }
}
</file>

<file path="lua/custom/plugins/dap_framework_config.lua.wip">
-- Framework-specific DAP configurations and templates
local M = {}

-- Base configuration template
local base_config = {
  type = 'python',
  request = 'launch',
  name = '',
  program = '',
  args = {},
  env = {},
  pythonPath = function()
    local venv = os.getenv('VIRTUAL_ENV')
    if venv then
      return venv .. '/bin/python'
    end
    return 'python'
  end
}

-- Framework-specific configurations
M.frameworks = {
  django = {
    template = vim.tbl_deep_extend('force', base_config, {
      name = 'Django',
      program = '${workspaceFolder}/manage.py',
      args = {'runserver', '--noreload'},
      django = true,
      console = 'integratedTerminal',
      env = {
        PYTHONUNBUFFERED = '1',
        DJANGO_SETTINGS_MODULE = '${workspaceFolderBasename}.settings'
      }
    }),
    
    detect = function()
      return vim.fn.filereadable('manage.py') == 1
    end,
    
    setup = function()
      return {
        project_name = vim.fn.fnamemodify(vim.fn.getcwd(), ':t'),
        settings_module = nil,  -- Will be auto-detected
        manage_path = vim.fn.getcwd() .. '/manage.py'
      }
    end
  },
  
  flask = {
    template = vim.tbl_deep_extend('force', base_config, {
      name = 'Flask',
      program = '${file}',
      env = {
        FLASK_APP = '${file}',
        FLASK_ENV = 'development',
        FLASK_DEBUG = '1'
      },
      args = {'run', '--no-debugger'},
      jinja = true,
      console = 'integratedTerminal'
    }),
    
    detect = function()
      local content = vim.fn.join(vim.fn.readfile(vim.fn.expand('%')), '\n')
      return content:match('from%s+flask%s+import%s+Flask')
    end,
    
    setup = function()
      return {
        app_name = vim.fn.expand('%:t:r'),
        host = '127.0.0.1',
        port = 5000
      }
    end
  },
  
  fastapi = {
    template = vim.tbl_deep_extend('force', base_config, {
      name = 'FastAPI',
      program = '${file}',
      args = {'--reload'},
      env = {
        PYTHONPATH = '${workspaceFolder}'
      },
      console = 'integratedTerminal'
    }),
    
    detect = function()
      local content = vim.fn.join(vim.fn.readfile(vim.fn.expand('%')), '\n')
      return content:match('from%s+fastapi%s+import%s+FastAPI')
    end,
    
    setup = function()
      return {
        app_name = vim.fn.expand('%:t:r'),
        host = '127.0.0.1',
        port = 8000
      }
    end
  },
  
  pyramid = {
    template = vim.tbl_deep_extend('force', base_config, {
      name = 'Pyramid',
      program = '${workspaceFolder}/development.ini',
      args = {'--reload'},
      console = 'integratedTerminal'
    }),
    
    detect = function()
      return vim.fn.filereadable('development.ini') == 1
    end,
    
    setup = function()
      return {
        config_file = 'development.ini',
        app_name = vim.fn.fnamemodify(vim.fn.getcwd(), ':t')
      }
    end
  }
}

-- Generate configuration for detected framework
function M.detect_and_configure()
  for name, framework in pairs(M.frameworks) do
    if framework.detect() then
      local config = vim.tbl_deep_extend('force', framework.template, {})
      local setup = framework.setup()
      
      -- Apply framework-specific configuration
      if name == 'django' then
        config.env.DJANGO_SETTINGS_MODULE = setup.project_name .. '.settings'
        config.program = setup.manage_path
      elseif name == 'flask' then
        config.env.FLASK_APP = setup.app_name .. '.py'
        config.args = {'run', '--host=' .. setup.host, '--port=' .. setup.port}
      elseif name == 'fastapi' then
        config.args = {'--host', setup.host, '--port', setup.port}
      elseif name == 'pyramid' then
        config.program = setup.config_file
      end
      
      return config
    end
  end
  
  -- Return default Python configuration if no framework detected
  return base_config
end

-- Create new framework configuration
function M.create_framework_config(name, config)
  if not M.frameworks[name] then
    M.frameworks[name] = {
      template = vim.tbl_deep_extend('force', base_config, config.template or {}),
      detect = config.detect or function() return false end,
      setup = config.setup or function() return {} end
    }
    return true
  end
  return false
end

-- Get all available framework configurations
function M.get_all_configs()
  local configs = {}
  for name, framework in pairs(M.frameworks) do
    configs[name] = vim.tbl_deep_extend('force', framework.template, {})
  end
  return configs
end

return M
</file>

<file path="lua/custom/plugins/dap_framework_test.lua.wip">
-- Framework-specific DAP tests
local M = {}

-- Utility functions
local function create_test_env()
  vim.fn.mkdir('test_project', 'p')
  vim.fn.chdir('test_project')
end

local function cleanup_test_env()
  vim.fn.chdir('..')
  vim.fn.delete('test_project', 'rf')
end

-- Django test environment
local django_tests = {
  setup = function()
    create_test_env()
    
    -- Create Django project structure
    os.execute('django-admin startproject testproject .')
    os.execute('python manage.py startapp testapp')
    
    -- Create test views
    local view_content = [[
from django.http import HttpResponse

def index(request):
    x = 1
    y = 2
    result = x + y  # Breakpoint here
    return HttpResponse(f"Result: {result}")
    ]]
    
    local f = io.open('testapp/views.py', 'w')
    if f then
      f:write(view_content)
      f:close()
    end
  end,
  
  cleanup = function()
    cleanup_test_env()
  end,
  
  tests = {
    test_django_breakpoint = function()
      local dap = require('dap')
      
      -- Configure Django debugging
      dap.configurations.python = {
        {
          type = 'python',
          request = 'launch',
          name = 'Django',
          program = vim.fn.getcwd() .. '/manage.py',
          args = {'runserver'},
          django = true
        }
      }
      
      -- Set breakpoint in views.py
      vim.cmd('edit testapp/views.py')
      vim.fn.cursor(5, 1)
      dap.toggle_breakpoint()
      
      return true
    end
  }
}

-- Flask test environment
local flask_tests = {
  setup = function()
    create_test_env()
    
    -- Create Flask application
    local app_content = [[
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    message = "Hello"  # Breakpoint here
    return message

if __name__ == '__main__':
    app.run(debug=True)
    ]]
    
    local f = io.open('app.py', 'w')
    if f then
      f:write(app_content)
      f:close()
    end
  end,
  
  cleanup = function()
    cleanup_test_env()
  end,
  
  tests = {
    test_flask_breakpoint = function()
      local dap = require('dap')
      
      -- Configure Flask debugging
      dap.configurations.python = {
        {
          type = 'python',
          request = 'launch',
          name = 'Flask',
          program = vim.fn.getcwd() .. '/app.py',
          env = {
            FLASK_APP = 'app.py',
            FLASK_ENV = 'development'
          }
        }
      }
      
      -- Set breakpoint in app.py
      vim.cmd('edit app.py')
      vim.fn.cursor(6, 1)
      dap.toggle_breakpoint()
      
      return true
    end
  }
}

-- FastAPI test environment
local fastapi_tests = {
  setup = function()
    create_test_env()
    
    -- Create FastAPI application
    local app_content = [[
from fastapi import FastAPI
app = FastAPI()

@app.get("/")
async def root():
    data = {"message": "Hello"}  # Breakpoint here
    return data
    ]]
    
    local f = io.open('main.py', 'w')
    if f then
      f:write(app_content)
      f:close()
    end
  end,
  
  cleanup = function()
    cleanup_test_env()
  end,
  
  tests = {
    test_fastapi_breakpoint = function()
      local dap = require('dap')
      
      -- Configure FastAPI debugging
      dap.configurations.python = {
        {
          type = 'python',
          request = 'launch',
          name = 'FastAPI',
          program = vim.fn.getcwd() .. '/main.py',
          env = {
            PYTHONPATH = vim.fn.getcwd()
          },
          args = {
            '--reload'
          }
        }
      }
      
      -- Set breakpoint in main.py
      vim.cmd('edit main.py')
      vim.fn.cursor(6, 1)
      dap.toggle_breakpoint()
      
      return true
    end
  }
}

-- Run framework-specific tests
function M.run_framework_tests()
  print("\n=== Running Framework-Specific Tests ===")
  
  local frameworks = {
    {name = "Django", suite = django_tests},
    {name = "Flask", suite = flask_tests},
    {name = "FastAPI", suite = fastapi_tests}
  }
  
  local results = {}
  
  for _, framework in ipairs(frameworks) do
    print(string.format("\nTesting %s Framework", framework.name))
    
    -- Setup framework environment
    framework.suite.setup()
    
    -- Run tests
    for name, test_fn in pairs(framework.suite.tests) do
      local success, result = pcall(test_fn)
      table.insert(results, {
        framework = framework.name,
        test = name,
        passed = success and result,
        error = not success and result or nil
      })
      
      print(string.format("  %s: %s",
        name,
        success and (result and "✓" or "✗") or "!"
      ))
      
      if not success then
        print("    Error: " .. result)
      end
    end
    
    -- Cleanup
    framework.suite.cleanup()
  end
  
  return results
end

return M
</file>

<file path="lua/custom/plugins/dap_mem_test.lua.wip">
-- Memory usage monitoring for DAP
local M = {}

-- Memory monitoring utilities
local function get_memory_usage()
  local memory_info = {}
  
  -- Get Lua memory usage
  memory_info.lua = collectgarbage('count') * 1024  -- Convert KB to bytes
  
  -- Get process memory if available
  if vim.loop.resident_set_memory then
    memory_info.process = vim.loop.resident_set_memory()
  end
  
  return memory_info
end

local function format_bytes(bytes)
  local units = {'B', 'KB', 'MB', 'GB'}
  local size = bytes
  local unit_index = 1
  
  while size > 1024 and unit_index < #units do
    size = size / 1024
    unit_index = unit_index + 1
  end
  
  return string.format("%.2f %s", size, units[unit_index])
end

local function measure_memory(fn, name)
  local before = get_memory_usage()
  
  -- Run the function
  fn()
  
  -- Trigger garbage collection for accurate measurement
  collectgarbage('collect')
  local after = get_memory_usage()
  
  -- Calculate differences
  local delta = {
    lua = after.lua - before.lua,
    process = (after.process and before.process) and (after.process - before.process) or nil
  }
  
  return {
    name = name,
    lua_delta = delta.lua,
    process_delta = delta.process,
    peak_lua = after.lua,
    peak_process = after.process
  }
end

-- Memory benchmarks
function M.benchmark_initialization()
  local results = {}
  
  -- Measure DAP setup memory
  table.insert(results, measure_memory(function()
    require('custom.plugins.dap').setup()
  end, "DAP Setup"))
  
  -- Measure UI initialization memory
  table.insert(results, measure_memory(function()
    require('dapui').setup()
  end, "DAP UI Setup"))
  
  return results
end

function M.benchmark_debugger_memory()
  local results = {}
  local dap = require('dap')
  
  -- Memory impact of setting breakpoints
  table.insert(results, measure_memory(function()
    for _ = 1, 5 do
      dap.toggle_breakpoint()
    end
  end, "Breakpoint Management"))
  
  -- Memory usage during virtual env detection
  table.insert(results, measure_memory(function()
    dap.configurations.python[1].pythonPath()
  end, "Virtual Env Detection"))
  
  return results
end

function M.run_memory_benchmarks()
  print("Running DAP Memory Usage Analysis...")
  
  local all_results = {}
  local benchmarks = {
    {name = "Initialization", fn = M.benchmark_initialization},
    {name = "Debugger Operations", fn = M.benchmark_debugger_memory}
  }
  
  -- Run all benchmarks
  for _, benchmark in ipairs(benchmarks) do
    print("\nExecuting " .. benchmark.name .. " memory analysis...")
    local results = benchmark.fn()
    
    -- Print results
    for _, result in ipairs(results) do
      print(string.format("\n%s:", result.name))
      print(string.format("  Lua Memory Delta: %s", format_bytes(result.lua_delta)))
      if result.process_delta then
        print(string.format("  Process Memory Delta: %s", format_bytes(result.process_delta)))
      end
      print(string.format("  Peak Lua Memory: %s", format_bytes(result.peak_lua)))
      if result.peak_process then
        print(string.format("  Peak Process Memory: %s", format_bytes(result.peak_process)))
      end
      table.insert(all_results, result)
    end
  end
  
  -- Memory usage summary
  print("\nMemory Usage Summary:")
  local total_lua_delta = 0
  local total_process_delta = 0
  for _, result in ipairs(all_results) do
    total_lua_delta = total_lua_delta + result.lua_delta
    if result.process_delta then
      total_process_delta = total_process_delta + result.process_delta
    end
  end
  
  print(string.format("Total Lua Memory Impact: %s", format_bytes(total_lua_delta)))
  if total_process_delta > 0 then
    print(string.format("Total Process Memory Impact: %s", format_bytes(total_process_delta)))
  end
  
  return all_results
end

return M
</file>

<file path="lua/custom/plugins/dap_perf_test.lua.wip">
local M = {}

-- Performance testing utilities
local function measure_time(fn, name)
  local start = vim.loop.hrtime()
  fn()
  local end_time = vim.loop.hrtime()
  local duration = (end_time - start) / 1000000 -- Convert to milliseconds
  return {
    name = name,
    duration = duration
  }
end

-- Performance benchmarks
function M.benchmark_initialization()
  local results = {}
  
  -- Measure DAP setup time
  table.insert(results, measure_time(function()
    require('custom.plugins.dap').setup()
  end, "DAP Setup"))
  
  -- Measure UI initialization
  table.insert(results, measure_time(function()
    require('dapui').setup()
  end, "DAP UI Setup"))
  
  return results
end

function M.benchmark_venv_detection()
  -- Create test environment
  os.execute('python -m venv perf_test_venv')
  
  local result = measure_time(function()
    local dap = require('dap')
    dap.configurations.python[1].pythonPath()
  end, "Virtual Environment Detection")
  
  -- Cleanup
  os.execute('rm -rf perf_test_venv')
  
  return {result}
end

function M.benchmark_breakpoint_operations()
  local dap = require('dap')
  local results = {}
  
  -- Measure breakpoint toggle
  table.insert(results, measure_time(function()
    dap.toggle_breakpoint()
  end, "Toggle Breakpoint"))
  
  -- Measure conditional breakpoint
  table.insert(results, measure_time(function()
    dap.set_breakpoint("i == 10")
  end, "Set Conditional Breakpoint"))
  
  return results
end

function M.run_benchmarks()
  print("Running DAP Performance Benchmarks...")
  
  local all_results = {}
  local benchmarks = {
    {name = "Initialization", fn = M.benchmark_initialization},
    {name = "Virtual Environment", fn = M.benchmark_venv_detection},
    {name = "Breakpoint Operations", fn = M.benchmark_breakpoint_operations}
  }
  
  -- Run all benchmarks
  for _, benchmark in ipairs(benchmarks) do
    print("\nExecuting " .. benchmark.name .. " benchmarks...")
    local results = benchmark.fn()
    
    -- Print results
    for _, result in ipairs(results) do
      print(string.format("  %s: %.2fms", result.name, result.duration))
      table.insert(all_results, result)
    end
  end
  
  -- Calculate statistics
  local total_time = 0
  local max_time = 0
  local max_operation = ""
  
  for _, result in ipairs(all_results) do
    total_time = total_time + result.duration
    if result.duration > max_time then
      max_time = result.duration
      max_operation = result.name
    end
  end
  
  -- Print summary
  print("\nPerformance Summary:")
  print(string.format("Total time: %.2fms", total_time))
  print(string.format("Average time: %.2fms", total_time / #all_results))
  print(string.format("Slowest operation: %s (%.2fms)", max_operation, max_time))
  
  return all_results
end

return M
</file>

<file path="lua/custom/plugins/dap_test_runner.lua.wip">
-- Enhanced DAP Test Runner with Framework Support
local functional_tests = require('custom.plugins.dap_test')
local perf_tests = require('custom.plugins.dap_perf_test')
local mem_tests = require('custom.plugins.dap_mem_test')
local framework_tests = require('custom.plugins.dap_framework_test')
local system_info = require('custom.plugins.system_info')
local report = require('custom.plugins.test_report')

-- Test configuration
local config = {
  setup_delay = 1000,      -- milliseconds to wait for DAP setup
  cleanup = true,          -- clean up test artifacts
  verbose = true,          -- detailed output
  check_thresholds = true, -- enforce thresholds
  frameworks = {           -- framework test configuration
    enabled = true,
    django = true,
    flask = true,
    fastapi = true
  }
}

-- Performance thresholds
local thresholds = {
  performance = {
    dap_setup = 500,
    ui_setup = 200,
    venv_detection = 100,
    breakpoint_toggle = 50,
    total_execution = 2000
  },
  memory = {
    dap_setup = 5 * 1024 * 1024,      -- 5MB
    ui_setup = 2 * 1024 * 1024,       -- 2MB
    breakpoint_management = 512 * 1024 -- 512KB
  }
}

-- Test environment setup
local function setup_test_env()
  print("Setting up test environment...")
  vim.cmd([[packadd nvim-dap]])
  vim.cmd([[packadd nvim-dap-ui]])
  require('custom.plugins.dap').setup()
  
  vim.defer_fn(function() 
    print("Test environment ready")
  end, config.setup_delay)
end

-- Test environment cleanup
local function cleanup_test_env()
  if config.cleanup then
    -- Clean up test artifacts
    local artifacts = {'test_venv', 'perf_test_venv', 'test_project'}
    for _, artifact in ipairs(artifacts) do
      if vim.fn.isdirectory(artifact) == 1 then
        vim.fn.delete(artifact, 'rf')
      end
    end
  end
end

-- Run all tests with framework support
local function run_all_tests()
  local start_time = vim.loop.hrtime()
  local total_failures = 0
  local test_results = {
    functional = {},
    performance = {},
    memory = {},
    framework = {}
  }
  
  -- Setup
  setup_test_env()
  
  vim.defer_fn(function()
    -- Collect system information
    local sys_info = system_info.collect_all()
    
    -- Run all test suites
    print("\n=== Running Functional Tests ===")
    test_results.functional = functional_tests.run_all_tests()
    
    print("\n=== Running Performance Tests ===")
    test_results.performance = perf_tests.run_benchmarks()
    
    print("\n=== Running Memory Tests ===")
    test_results.memory = mem_tests.run_memory_benchmarks()
    
    -- Run framework tests if enabled
    if config.frameworks.enabled then
      print("\n=== Running Framework Tests ===")
      test_results.framework = framework_tests.run_framework_tests()
      
      -- Count framework test failures
      for _, result in ipairs(test_results.framework) do
        if not result.passed then
          total_failures = total_failures + 1
        end
      end
    end
    
    -- Check thresholds
    if config.check_thresholds then
      -- Performance violations check
      for _, result in ipairs(test_results.performance) do
        local threshold = thresholds.performance[result.name:lower():gsub("%s+", "_")]
        if threshold and result.duration > threshold then
          total_failures = total_failures + 1
        end
      end
      
      -- Memory violations check
      for _, result in ipairs(test_results.memory) do
        local threshold = thresholds.memory[result.name:lower():gsub("%s+", "_")]
        if threshold and result.lua_delta > threshold then
          total_failures = total_failures + 1
        end
      end
    end
    
    -- Calculate total execution time
    local end_time = vim.loop.hrtime()
    local total_time = (end_time - start_time) / 1000000
    
    -- Generate and save test report
    local test_report = report.generate_report(test_results, total_time, total_failures, thresholds, sys_info)
    local report_file = report.save_report(test_report)
    
    -- Cleanup
    cleanup_test_env()
    
    -- Final summary
    print(string.format("\nTest Suite Complete (%.2fms)", total_time))
    print(string.format("Total Failures: %d", total_failures))
    if report_file then
      print("Detailed report saved to: " .. report_file)
    end
    
    if total_failures > 0 then
      vim.api.nvim_err_writeln("Test suite failed with errors")
    end
  end, config.setup_delay + 100)
end

-- Command to run all tests
vim.api.nvim_create_user_command('TestDAPAll', run_all_tests, {})

-- Command to run framework-specific tests only
vim.api.nvim_create_user_command('TestDAPFrameworks', function()
  framework_tests.run_framework_tests()
end, {})

-- Return the runner for programmatic usage
return {
  run = run_all_tests,
  run_frameworks = framework_tests.run_framework_tests,
  config = config,
  thresholds = thresholds
}
</file>

<file path="lua/custom/plugins/dap_test.lua.wip">
local M = {}
local dap = require('dap')

-- Test utilities
local function create_test_venv()
  os.execute('python -m venv test_venv')
end

local function cleanup_test_venv()
  os.execute('rm -rf test_venv')
end

-- Test cases
function M.test_venv_detection()
  create_test_venv()
  
  local python_path = dap.configurations.python[1].pythonPath()
  assert(python_path:match("test_venv/bin/python"),
         "Virtual environment not detected correctly")
         
  cleanup_test_venv()
end

function M.test_dap_configurations()
  -- Test Python configuration structure
  local config = dap.configurations.python[1]
  assert(config.type == 'python', "Invalid adapter type")
  assert(config.request == 'launch', "Invalid request type")
  assert(config.program == '${file}', "Invalid program path")
  assert(type(config.pythonPath) == 'function', "pythonPath should be a function")
  
  -- Test remote debugging configuration
  local remote_config = dap.configurations.python[2]
  assert(remote_config.type == 'python', "Invalid remote adapter type")
  assert(remote_config.request == 'attach', "Invalid remote request type")
  assert(remote_config.connect.port == 5678, "Invalid remote debug port")
end

function M.test_ui_integration()
  -- Test DAP UI setup
  local status, dapui = pcall(require, 'dapui')
  assert(status, "nvim-dap-ui not found")
  
  -- Test event listeners
  assert(dap.listeners.after.event_initialized['dapui_config'],
         "UI initialization listener not configured")
  assert(dap.listeners.before.event_terminated['dapui_config'],
         "UI termination listener not configured")
end

function M.test_framework_support()
  local config = dap.configurations.python[1]
  
  -- Test framework debug options
  local debug_options = config.debugOptions
  assert(vim.tbl_contains(debug_options, 'Django'), "Django support missing")
  assert(vim.tbl_contains(debug_options, 'Flask'), "Flask support missing")
  assert(vim.tbl_contains(debug_options, 'Pyramid'), "Pyramid support missing")
end

function M.run_all_tests()
  print("Running DAP configuration tests...")
  
  local tests = {
    "test_venv_detection",
    "test_dap_configurations",
    "test_ui_integration",
    "test_framework_support"
  }
  
  local failures = 0
  for _, test in ipairs(tests) do
    print("\nRunning " .. test)
    local status, error = pcall(M[test])
    if not status then
      print("FAILED: " .. error)
      failures = failures + 1
    else
      print("PASSED")
    end
  end
  
  print(string.format("\nTest summary: %d passed, %d failed", 
        #tests - failures, failures))
end

return M
</file>

<file path="lua/custom/plugins/dap.lua">
return {
  {
    'mfussenegger/nvim-dap',
    config = function()
      local dap = require 'dap'
      -- Basic DAP setup
      dap.defaults.fallback.terminal_win_cmd = '50vsplit new'

      -- Performance monitoring configuration
      dap.defaults.fallback.focus_terminal = true
      dap.defaults.fallback.auto_continue_if_many_stopped = false

      -- Initialize configurations table if not exists
      dap.configurations = dap.configurations or {}
      dap.configurations.python = dap.configurations.python or {}
    end,
  },
  {
    'rcarriga/nvim-dap-ui',
    dependencies = { 'mfussenegger/nvim-dap' },
    config = function()
      local dapui = require 'dapui'
      dapui.setup {
        layouts = {
          {
            elements = {
              -- Performance monitoring elements
              { id = 'scopes', size = 0.25 },
              { id = 'breakpoints', size = 0.25 },
              { id = 'stacks', size = 0.25 },
              { id = 'watches', size = 0.25 },
            },
            position = 'left',
            size = 40,
          },
          {
            elements = {
              { id = 'repl', size = 0.5 },
              { id = 'console', size = 0.5 },
            },
            position = 'bottom',
            size = 10,
          },
        },
      }

      -- Auto-open UI on debug events
      local dap = require 'dap'
      dap.listeners.after.event_initialized['dapui_config'] = function()
        dapui.open()
      end
    end,
  },
  {
    'mfussenegger/nvim-dap-python',
    dependencies = {
      'mfussenegger/nvim-dap',
      'rcarriga/nvim-dap-ui',
    },
    config = function()
      local dap = require 'dap'
      local dap_python = require 'dap-python'

      -- Setup Python debugger with performance monitoring
      dap_python.setup()

      -- Framework configurations with performance settings
      local frameworks = {
        django = {
          type = 'python',
          request = 'launch',
          name = 'Django',
          program = '${workspaceFolder}/manage.py',
          args = { 'runserver', '--noreload' },
          pythonPath = function()
            return vim.fn.exepath 'python'
          end,
          django = true,
          console = 'integratedTerminal',
          justMyCode = false, -- Enable debugging of library code
          env = {
            DJANGO_SETTINGS_MODULE = '${workspaceFolderBasename}.settings',
            PYTHONUNBUFFERED = '1',
          },
        },
        fastapi = {
          type = 'python',
          request = 'launch',
          name = 'FastAPI',
          program = '${file}',
          args = { '--reload' },
          pythonPath = function()
            return vim.fn.exepath 'python'
          end,
          console = 'integratedTerminal',
          justMyCode = false, -- Enable debugging of library code
          env = {
            PYTHONPATH = '${workspaceFolder}',
          },
        },
      }

      -- Add framework configurations
      for _, config in pairs(frameworks) do
        table.insert(dap.configurations.python, config)
      end

      -- Add performance monitoring configuration
      table.insert(dap.configurations.python, {
        type = 'python',
        request = 'launch',
        name = 'Python: Profile Current File',
        program = '${file}',
        pythonPath = function()
          return vim.fn.exepath 'python'
        end,
        console = 'integratedTerminal',
        justMyCode = false,
        env = {
          PYTHONPROFILEIMPORTTIME = '1',
        },
      })
    end,
  },
}
</file>

<file path="lua/custom/plugins/git.lua">
return {
  {
    'tpope/vim-fugitive',
    event = 'VeryLazy',
    dependencies = {
      'nvim-telescope/telescope.nvim',
      'folke/which-key.nvim',
    },
    config = function()
      -- Set up which-key integration
      local wk = require('which-key')
      wk.register({
        g = {
          name = '[G]it',
          s = { "<cmd>Git<cr>", "Status" },
          p = { "<cmd>Git push<cr>", "Push" },
          P = { "<cmd>Git pull<cr>", "Pull" },
          b = { "<cmd>Git blame<cr>", "Blame" },
          B = { "<cmd>Telescope git_branches<cr>", "Branches" },
          c = { "<cmd>Git commit<cr>", "Commit" },
          d = { "<cmd>Gvdiffsplit<cr>", "Diff" },
          l = { "<cmd>Telescope git_commits<cr>", "Log" },
          h = { "<cmd>0Gclog<cr>", "File History" },
          S = { "<cmd>Git stash<cr>", "Stash" },
          f = { "<cmd>Telescope git_files<cr>", "Git Files" },
        },
      }, { prefix = "<leader>" })

      -- Configure statusline Git integration with mini.statusline
      local M = {}
      
      -- Safe require for mini.statusline
      local ok_mini, statusline = pcall(require, 'mini.statusline')
      if not ok_mini then
        return
      end

      -- Store original git section function
      local default_section_git = statusline.section_git

      -- New safe git section implementation
      statusline.section_git = function()
        -- Guard against missing default function
        if type(default_section_git) ~= 'function' then
          return ''
        end

        -- Safely get git info
        local git_info = ''
        local ok_git, result = pcall(default_section_git)
        if ok_git and result then
          git_info = result
        end

        -- Early return if no git info
        if git_info == '' then
          return ''
        end

        -- Safely get branch name
        local branch = ''
        local ok_head, head = pcall(vim.fn.FugitiveHead)
        if ok_head and head and head ~= '' then
          branch = head
        end

        -- Return formatted string
        return string.format(' %s', branch ~= '' and branch or git_info)
      end

      -- Set up additional Telescope Git pickers
      local builtin = require('telescope.builtin')
      vim.keymap.set('n', '<leader>gC', builtin.git_bcommits, { desc = 'Git Buffer Commits' })
      vim.keymap.set('n', '<leader>gs', builtin.git_status, { desc = 'Git Status' })
      vim.keymap.set('n', '<leader>gS', builtin.git_stash, { desc = 'Git Stash' })

      -- Custom Git command aliases
      vim.api.nvim_create_user_command('Gpush', 'Git push', {})
      vim.api.nvim_create_user_command('Gpull', 'Git pull', {})
      vim.api.nvim_create_user_command('Gfetch', 'Git fetch', {})
      vim.api.nvim_create_user_command('Gcommit', 'Git commit', {})
    end,
  },
}
</file>

<file path="lua/custom/plugins/init.lua">
-- You can add your own plugins here or in other files in this directory!
--  I promise not to create any merge conflicts in this directory :)
--
-- See the kickstart.nvim README for more information
return {
  {
    'mfussenegger/nvim-dap',
    keys = {
      { '<F5>', desc = 'Start/Continue Debug' },
      { '<F10>', desc = 'Step Over' },
      { '<F11>', desc = 'Step Into' },
      { '<F12>', desc = 'Step Out' },
      { '<Leader>b', desc = 'Toggle Breakpoint' },
      { '<Leader>B', desc = 'Conditional Breakpoint' },
      { '<Leader>lp', desc = 'Log Point' },
    },
    dependencies = {
      'rcarriga/nvim-dap-ui',
    },
    config = function()
      local dap = require('dap')
      local framework_config = require('custom.plugins.dap_framework_config')
      
      -- Initialize base DAP setup
      require('custom.plugins.dap').setup()
      
      -- Add framework-specific configurations to Python configurations
      for name, config in pairs(framework_config.frameworks) do
        if type(config) == 'table' and config.template then
          table.insert(dap.configurations.python, config.template)
        end
      end
    end,
  }
}
</file>

<file path="lua/custom/plugins/keymaps.lua">
return {
  -- Custom keymaps with which-key integration
  {
    "folke/which-key.nvim",
    event = "VeryLazy",
    init = function()
      vim.o.timeout = true
      vim.o.timeoutlen = 300
    end,
    opts = {
      plugins = {
        marks = true,
        registers = true,
        spelling = { enabled = false },
        presets = {
          operators = true,
          motions = true,
          text_objects = true,
          windows = true,
          nav = true,
          z = true,
          g = true,
        },
      },
      window = {
        border = "single",
        position = "bottom",
      },
      show_help = true,
      show_keys = true,
    },
    config = function(_, opts)
      local wk = require("which-key")
      wk.setup(opts)
      
      -- Register all our mapping groups
      wk.register({
        ["<leader>"] = {
          f = { name = "+file" },
          b = { name = "+buffer" },
          w = { name = "+window" },
          g = { name = "+git" },
          l = { name = "+lsp" },
          s = { name = "+search" },
          c = { name = "+code", mode = { "n", "v" } },
          d = { name = "+document" },
          t = { name = "+toggle" },
          h = { name = "+hunk", mode = { "n", "v" } },
        }
      })
    end,
  }
}
</file>

<file path="lua/custom/plugins/run_dap_tests.lua.wip">
-- DAP Test Runner
local tests = require('custom.plugins.dap_test')

-- Configuration
local config = {
  setup_delay = 1000,  -- milliseconds to wait for DAP setup
  cleanup = true,      -- clean up test artifacts
  verbose = true       -- detailed output
}

-- Test environment setup
local function setup_test_env()
  -- Ensure required plugins are available
  vim.cmd([[packadd nvim-dap]])
  vim.cmd([[packadd nvim-dap-ui]])
  
  -- Load DAP configuration
  require('custom.plugins.dap').setup()
  
  -- Wait for setup to complete
  vim.defer_fn(function() 
    print("Test environment ready")
  end, config.setup_delay)
end

-- Test environment cleanup
local function cleanup_test_env()
  if config.cleanup then
    -- Clean up any test artifacts
    if vim.fn.isdirectory('test_venv') == 1 then
      vim.fn.delete('test_venv', 'rf')
    end
  end
end

-- Run tests with proper setup/teardown
local function run_tests()
  print("Setting up test environment...")
  setup_test_env()
  
  vim.defer_fn(function()
    -- Run all tests
    tests.run_all_tests()
    
    -- Cleanup
    cleanup_test_env()
    
    print("\nTest execution completed.")
  end, config.setup_delay + 100)
end

-- Command to run tests
vim.api.nvim_create_user_command('TestDAP', run_tests, {})

-- Return the runner for programmatic usage
return {
  run = run_tests,
  config = config
}
</file>

<file path="lua/custom/plugins/system_info.lua.wip">
-- System Information Collection for DAP Testing
local M = {}

-- Get Neovim version and build info
function M.get_nvim_info()
  return {
    version = vim.version(),
    build_type = vim.fn.has('nvim-0.5') == 1 and 'stable' or 'development',
    platform = vim.fn.has('win32') == 1 and 'windows' or vim.fn.has('macunix') == 1 and 'macos' or 'linux',
    features = {
      python = vim.fn.has('python3') == 1,
      lua = vim.fn.has('lua') == 1,
      terminal = vim.fn.has('terminal') == 1
    }
  }
end

-- Get plugin versions
function M.get_plugin_versions()
  local plugins = {
    dap = package.loaded['dap'],
    dapui = package.loaded['dapui'],
    debugpy = vim.fn.executable('debugpy-adapter') == 1
  }
  
  return plugins
end

-- Get Python environment info
function M.get_python_info()
  local python_info = {}
  
  -- Get Python version
  local python_version = vim.fn.system('python --version 2>&1'):match('Python%s+([%d%.]+)')
  python_info.version = python_version or 'not found'
  
  -- Check virtual environment
  python_info.venv = os.getenv('VIRTUAL_ENV')
  
  -- Check debugpy installation
  local debugpy_check = vim.fn.system('pip show debugpy 2>/dev/null')
  python_info.debugpy = debugpy_check ~= '' and true or false
  
  -- Check web frameworks
  python_info.frameworks = {
    django = vim.fn.system('pip show django 2>/dev/null') ~= '',
    flask = vim.fn.system('pip show flask 2>/dev/null') ~= '',
    pyramid = vim.fn.system('pip show pyramid 2>/dev/null') ~= ''
  }
  
  return python_info
end

-- Get system resources
function M.get_system_resources()
  local resources = {}
  
  -- Memory information
  if vim.loop.get_free_memory then
    local total_memory = vim.loop.get_total_memory()
    local free_memory = vim.loop.get_free_memory()
    resources.memory = {
      total = total_memory,
      free = free_memory,
      used = total_memory - free_memory
    }
  end
  
  -- CPU information
  if vim.loop.cpu_info then
    resources.cpu = vim.loop.cpu_info()
  end
  
  -- Process information
  if vim.loop.getrusage then
    resources.process = vim.loop.getrusage()
  end
  
  return resources
end

-- Get complete system information
function M.collect_all()
  return {
    timestamp = os.time(),
    nvim = M.get_nvim_info(),
    plugins = M.get_plugin_versions(),
    python = M.get_python_info(),
    system = M.get_system_resources()
  }
end

-- Format system information for report
function M.format_for_report(info)
  local lines = {
    "## System Information",
    "",
    "### Neovim",
    "```",
    string.format("Version: %s.%s.%s", info.nvim.version.major, info.nvim.version.minor, info.nvim.version.patch),
    string.format("Build: %s", info.nvim.build_type),
    string.format("Platform: %s", info.nvim.platform),
    "```",
    "",
    "### Plugins",
    "```",
    string.format("DAP: %s", info.plugins.dap and "✓" or "✗"),
    string.format("DAP UI: %s", info.plugins.dapui and "✓" or "✗"),
    string.format("debugpy: %s", info.plugins.debugpy and "✓" or "✗"),
    "```",
    "",
    "### Python Environment",
    "```",
    string.format("Version: %s", info.python.version),
    string.format("Virtual Environment: %s", info.python.venv or "none"),
    string.format("debugpy: %s", info.python.debugpy and "installed" or "not found"),
    "",
    "Frameworks:",
    string.format("- Django: %s", info.python.frameworks.django and "✓" or "✗"),
    string.format("- Flask: %s", info.python.frameworks.flask and "✓" or "✗"),
    string.format("- Pyramid: %s", info.python.frameworks.pyramid and "✓" or "✗"),
    "```"
  }
  
  -- Add system resources if available
  if info.system.memory then
    table.insert(lines, "")
    table.insert(lines, "### System Resources")
    table.insert(lines, "```")
    table.insert(lines, string.format("Memory Total: %s", M.format_bytes(info.system.memory.total)))
    table.insert(lines, string.format("Memory Free: %s", M.format_bytes(info.system.memory.free)))
    table.insert(lines, string.format("Memory Used: %s", M.format_bytes(info.system.memory.used)))
    table.insert(lines, "```")
  end
  
  return table.concat(lines, "\n")
end

-- Utility function to format bytes
function M.format_bytes(bytes)
  local units = {'B', 'KB', 'MB', 'GB'}
  local size = bytes
  local unit_index = 1
  
  while size > 1024 and unit_index < #units do
    size = size / 1024
    unit_index = unit_index + 1
  end
  
  return string.format("%.2f %s", size, units[unit_index])
end

return M
</file>

<file path="lua/custom/plugins/test_report.lua.wip">
-- Enhanced DAP Test Report Generator with System Information
local M = {}
local system_info = require('custom.plugins.system_info')

-- Format utilities
local function format_bytes(bytes)
  local units = {'B', 'KB', 'MB', 'GB'}
  local size = bytes
  local unit_index = 1
  
  while size > 1024 and unit_index < #units do
    size = size / 1024
    unit_index = unit_index + 1
  end
  
  return string.format("%.2f %s", size, units[unit_index])
end

local function format_duration(ms)
  if ms < 1 then
    return string.format("%.3f ms", ms)
  else
    return string.format("%.2f ms", ms)
  end
end

-- Generate report sections
local function generate_header()
  local lines = {
    "# DAP Test Report",
    "",
    string.format("Generated: %s", os.date()),
    "",
    "---",
    ""
  }
  return table.concat(lines, "\n")
end

local function generate_system_section()
  local sys_info = system_info.collect_all()
  return system_info.format_for_report(sys_info)
end

local function generate_test_summary(results, total_time, failures)
  local lines = {
    "",
    "## Test Summary",
    "```",
    string.format("Total Execution Time: %s", format_duration(total_time)),
    string.format("Test Cases: %d", #results.functional + #results.performance + #results.memory),
    string.format("Failures: %d", failures),
    "```",
    ""
  }
  return table.concat(lines, "\n")
end

local function generate_functional_section(results)
  local lines = {
    "## Functional Tests",
    "",
    "| Test | Status | Details |",
    "|------|--------|---------|"
  }
  
  for _, result in ipairs(results) do
    table.insert(lines, string.format("| %s | %s | %s |",
      result.name,
      result.passed and "✅ PASS" or "❌ FAIL",
      result.details or "N/A"
    ))
  end
  
  table.insert(lines, "")
  return table.concat(lines, "\n")
end

local function generate_performance_section(results, thresholds)
  local lines = {
    "## Performance Tests",
    "",
    "| Operation | Duration | Threshold | Status |",
    "|-----------|----------|-----------|--------|"
  }
  
  for _, result in ipairs(results) do
    local threshold = thresholds.performance[result.name:lower():gsub("%s+", "_")]
    table.insert(lines, string.format("| %s | %s | %s | %s |",
      result.name,
      format_duration(result.duration),
      threshold and format_duration(threshold) or "N/A",
      threshold and result.duration <= threshold and "✅" or "⚠️"
    ))
  end
  
  table.insert(lines, "")
  return table.concat(lines, "\n")
end

local function generate_memory_section(results, thresholds)
  local lines = {
    "## Memory Usage",
    "",
    "| Operation | Lua Memory | Process Memory | Threshold | Status |",
    "|-----------|------------|----------------|-----------|--------|"
  }
  
  for _, result in ipairs(results) do
    local threshold = thresholds.memory[result.name:lower():gsub("%s+", "_")]
    table.insert(lines, string.format("| %s | %s | %s | %s | %s |",
      result.name,
      format_bytes(result.lua_delta),
      result.process_delta and format_bytes(result.process_delta) or "N/A",
      threshold and format_bytes(threshold) or "N/A",
      threshold and result.lua_delta <= threshold and "✅" or "⚠️"
    ))
  end
  
  table.insert(lines, "")
  return table.concat(lines, "\n")
end

local function generate_recommendations(results, thresholds)
  local lines = {"## Recommendations", ""}
  local issues = {}
  
  -- Performance issues
  for _, result in ipairs(results.performance) do
    local threshold = thresholds.performance[result.name:lower():gsub("%s+", "_")]
    if threshold and result.duration > threshold then
      table.insert(issues, string.format(
        "- Performance: %s exceeds threshold (current: %s, target: %s)",
        result.name,
        format_duration(result.duration),
        format_duration(threshold)
      ))
    end
  end
  
  -- Memory issues
  for _, result in ipairs(results.memory) do
    local threshold = thresholds.memory[result.name:lower():gsub("%s+", "_")]
    if threshold and result.lua_delta > threshold then
      table.insert(issues, string.format(
        "- Memory: %s exceeds threshold (current: %s, target: %s)",
        result.name,
        format_bytes(result.lua_delta),
        format_bytes(threshold)
      ))
    end
  end
  
  if #issues > 0 then
    table.insert(lines, "### Areas for Improvement")
    for _, issue in ipairs(issues) do
      table.insert(lines, issue)
    end
  else
    table.insert(lines, "✅ All tests are within acceptable thresholds.")
  end
  
  table.insert(lines, "")
  return table.concat(lines, "\n")
end

-- Main report generation function
function M.generate_report(results, total_time, failures, thresholds)
  local sections = {
    generate_header(),
    generate_system_section(),
    generate_test_summary(results, total_time, failures),
    generate_functional_section(results.functional),
    generate_performance_section(results.performance, thresholds),
    generate_memory_section(results.memory, thresholds),
    generate_recommendations(results, thresholds)
  }
  
  return table.concat(sections, "\n")
end

-- Save report to file
function M.save_report(report)
  -- Create reports directory if it doesn't exist
  vim.fn.mkdir('test-reports', 'p')
  
  -- Generate filename with timestamp
  local filename = string.format('test-reports/dap_test_report_%s.md',
    os.date('%Y%m%d_%H%M%S'))
  
  local file = io.open(filename, 'w')
  if file then
    file:write(report)
    file:close()
    return filename
  end
  return nil
end

return M
</file>

<file path="lua/kickstart/plugins/autopairs.lua">
-- autopairs
-- https://github.com/windwp/nvim-autopairs

return {
  'windwp/nvim-autopairs',
  event = 'InsertEnter',
  -- Optional dependency
  dependencies = { 'hrsh7th/nvim-cmp' },
  config = function()
    require('nvim-autopairs').setup {}
    -- If you want to automatically add `(` after selecting a function or method
    local cmp_autopairs = require 'nvim-autopairs.completion.cmp'
    local cmp = require 'cmp'
    cmp.event:on('confirm_done', cmp_autopairs.on_confirm_done())
  end,
}
</file>

<file path="lua/kickstart/plugins/debug.lua">
-- debug.lua
--
-- Debugger configuration with focus on Python support while maintaining
-- existing Go debugging capabilities
--

return {
  -- Core DAP plugin
  'mfussenegger/nvim-dap',
  -- Dependencies
  dependencies = {
    -- Beautiful debugger UI
    'rcarriga/nvim-dap-ui',
    -- Required for nvim-dap-ui
    'nvim-neotest/nvim-nio',
    -- Debugger installation manager
    'williamboman/mason.nvim',
    'jay-babu/mason-nvim-dap.nvim',
    -- Language specific debuggers
    'mfussenegger/nvim-dap-python',  -- Python
    'leoluz/nvim-dap-go',            -- Go
  },
  config = function()
    local dap = require('dap')
    local dapui = require('dapui')

    -- Mason-nvim-dap setup
    require('mason-nvim-dap').setup({
      automatic_installation = true,
      ensure_installed = {
        'debugpy',  -- Python debugger
        'delve',    -- Go debugger
      },
      handlers = {
        function(config)
          -- All sources with no handler get passed here
          require('mason-nvim-dap').default_setup(config)
        end,
        python = function(config)
          -- Load custom Python configuration
          require('custom.plugins.dap').setup()
        end,
      },
    })

    -- DAP UI setup with consistent styling
    dapui.setup({
      -- Set icons to characters that work in every terminal
      icons = { expanded = '▾', collapsed = '▸', current_frame = '*' },
      controls = {
        icons = {
          pause = '⏸',
          play = '▶',
          step_into = '⏎',
          step_over = '⏭',
          step_out = '⏮',
          step_back = 'b',
          run_last = '▶▶',
          terminate = '⏹',
          disconnect = '⏏',
        },
      },
      layouts = {
        {
          elements = {
            'scopes',
            'breakpoints',
            'stacks',
            'watches',
          },
          size = 40,
          position = 'left',
        },
        {
          elements = {
            'repl',
            'console',
          },
          size = 10,
          position = 'bottom',
        },
      },
    })

    -- Event listeners for UI
    dap.listeners.after.event_initialized['dapui_config'] = dapui.open
    dap.listeners.before.event_terminated['dapui_config'] = dapui.close
    dap.listeners.before.event_exited['dapui_config'] = dapui.close

    -- Go debugger setup (preserved from original)
    require('dap-go').setup({
      delve = {
        detached = vim.fn.has('win32') == 0,
      },
    })

    -- Keymaps for debugging
    local keymap = vim.keymap.set
    local opts = { noremap = true, silent = true }

    -- Override F-keys to avoid conflicts with Python debugger
    keymap('n', '<F5>', dap.continue, opts)
    keymap('n', '<F10>', dap.step_over, opts)
    keymap('n', '<F11>', dap.step_into, opts)
    keymap('n', '<F12>', dap.step_out, opts)
    
    -- Additional debug commands
    keymap('n', '<Leader>b', dap.toggle_breakpoint, opts)
    keymap('n', '<Leader>B', function()
      dap.set_breakpoint(vim.fn.input('Breakpoint condition: '))
    end, opts)
    keymap('n', '<F7>', dapui.toggle, opts)
  end,
}
</file>

<file path="lua/kickstart/plugins/gitsigns.lua">
-- Adds git related signs to the gutter, as well as utilities for managing changes
-- NOTE: gitsigns is already included in init.lua but contains only the base
-- config. This will add also the recommended keymaps.

return {
  {
    'lewis6991/gitsigns.nvim',
    opts = {
      on_attach = function(bufnr)
        local gitsigns = require 'gitsigns'

        local function map(mode, l, r, opts)
          opts = opts or {}
          opts.buffer = bufnr
          vim.keymap.set(mode, l, r, opts)
        end

        -- Navigation
        map('n', ']c', function()
          if vim.wo.diff then
            vim.cmd.normal { ']c', bang = true }
          else
            gitsigns.nav_hunk 'next'
          end
        end, { desc = 'Jump to next git [c]hange' })

        map('n', '[c', function()
          if vim.wo.diff then
            vim.cmd.normal { '[c', bang = true }
          else
            gitsigns.nav_hunk 'prev'
          end
        end, { desc = 'Jump to previous git [c]hange' })

        -- Actions
        -- visual mode
        map('v', '<leader>hs', function()
          gitsigns.stage_hunk { vim.fn.line '.', vim.fn.line 'v' }
        end, { desc = 'git [s]tage hunk' })
        map('v', '<leader>hr', function()
          gitsigns.reset_hunk { vim.fn.line '.', vim.fn.line 'v' }
        end, { desc = 'git [r]eset hunk' })
        -- normal mode
        map('n', '<leader>hs', gitsigns.stage_hunk, { desc = 'git [s]tage hunk' })
        map('n', '<leader>hr', gitsigns.reset_hunk, { desc = 'git [r]eset hunk' })
        map('n', '<leader>hS', gitsigns.stage_buffer, { desc = 'git [S]tage buffer' })
        map('n', '<leader>hu', gitsigns.stage_hunk, { desc = 'git [u]ndo stage hunk' })
        map('n', '<leader>hR', gitsigns.reset_buffer, { desc = 'git [R]eset buffer' })
        map('n', '<leader>hp', gitsigns.preview_hunk, { desc = 'git [p]review hunk' })
        map('n', '<leader>hb', gitsigns.blame_line, { desc = 'git [b]lame line' })
        map('n', '<leader>hd', gitsigns.diffthis, { desc = 'git [d]iff against index' })
        map('n', '<leader>hD', function()
          gitsigns.diffthis '@'
        end, { desc = 'git [D]iff against last commit' })
        -- Toggles
        map('n', '<leader>tb', gitsigns.toggle_current_line_blame, { desc = '[T]oggle git show [b]lame line' })
        map('n', '<leader>tD', gitsigns.preview_hunk_inline, { desc = '[T]oggle git show [D]eleted' })
      end,
    },
  },
}
</file>

<file path="lua/kickstart/plugins/indent_line.lua">
return {
  { -- Add indentation guides even on blank lines
    'lukas-reineke/indent-blankline.nvim',
    -- Enable `lukas-reineke/indent-blankline.nvim`
    -- See `:help ibl`
    main = 'ibl',
    opts = {},
  },
}
</file>

<file path="lua/kickstart/plugins/lint.lua">
return {

  { -- Linting
    'mfussenegger/nvim-lint',
    event = { 'BufReadPre', 'BufNewFile' },
    config = function()
      local lint = require 'lint'
      lint.linters_by_ft = {
        markdown = { 'markdownlint' },
      }

      -- To allow other plugins to add linters to require('lint').linters_by_ft,
      -- instead set linters_by_ft like this:
      -- lint.linters_by_ft = lint.linters_by_ft or {}
      -- lint.linters_by_ft['markdown'] = { 'markdownlint' }
      --
      -- However, note that this will enable a set of default linters,
      -- which will cause errors unless these tools are available:
      -- {
      --   clojure = { "clj-kondo" },
      --   dockerfile = { "hadolint" },
      --   inko = { "inko" },
      --   janet = { "janet" },
      --   json = { "jsonlint" },
      --   markdown = { "vale" },
      --   rst = { "vale" },
      --   ruby = { "ruby" },
      --   terraform = { "tflint" },
      --   text = { "vale" }
      -- }
      --
      -- You can disable the default linters by setting their filetypes to nil:
      -- lint.linters_by_ft['clojure'] = nil
      -- lint.linters_by_ft['dockerfile'] = nil
      -- lint.linters_by_ft['inko'] = nil
      -- lint.linters_by_ft['janet'] = nil
      -- lint.linters_by_ft['json'] = nil
      -- lint.linters_by_ft['markdown'] = nil
      -- lint.linters_by_ft['rst'] = nil
      -- lint.linters_by_ft['ruby'] = nil
      -- lint.linters_by_ft['terraform'] = nil
      -- lint.linters_by_ft['text'] = nil

      -- Create autocommand which carries out the actual linting
      -- on the specified events.
      local lint_augroup = vim.api.nvim_create_augroup('lint', { clear = true })
      vim.api.nvim_create_autocmd({ 'BufEnter', 'BufWritePost', 'InsertLeave' }, {
        group = lint_augroup,
        callback = function()
          -- Only run the linter in buffers that you can modify in order to
          -- avoid superfluous noise, notably within the handy LSP pop-ups that
          -- describe the hovered symbol using Markdown.
          if vim.opt_local.modifiable:get() then
            lint.try_lint()
          end
        end,
      })
    end,
  },
}
</file>

<file path="lua/kickstart/plugins/neo-tree.lua">
-- Neo-tree is a Neovim plugin to browse the file system
-- https://github.com/nvim-neo-tree/neo-tree.nvim

return {
  'nvim-neo-tree/neo-tree.nvim',
  version = '*',
  dependencies = {
    'nvim-lua/plenary.nvim',
    'nvim-tree/nvim-web-devicons', -- not strictly required, but recommended
    'MunifTanjim/nui.nvim',
  },
  cmd = 'Neotree',
  keys = {
    { '\\', ':Neotree reveal<CR>', desc = 'NeoTree reveal', silent = true },
  },
  opts = {
    filesystem = {
      window = {
        mappings = {
          ['\\'] = 'close_window',
        },
      },
    },
  },
}
</file>

<file path="lua/kickstart/health.lua">
--[[
--
-- This file is not required for your own configuration,
-- but helps people determine if their system is setup correctly.
--
--]]

local check_version = function()
  local verstr = tostring(vim.version())
  if not vim.version.ge then
    vim.health.error(string.format("Neovim out of date: '%s'. Upgrade to latest stable or nightly", verstr))
    return
  end

  if vim.version.ge(vim.version(), '0.10-dev') then
    vim.health.ok(string.format("Neovim version is: '%s'", verstr))
  else
    vim.health.error(string.format("Neovim out of date: '%s'. Upgrade to latest stable or nightly", verstr))
  end
end

local check_external_reqs = function()
  -- Basic utils: `git`, `make`, `unzip`
  for _, exe in ipairs { 'git', 'make', 'unzip', 'rg' } do
    local is_executable = vim.fn.executable(exe) == 1
    if is_executable then
      vim.health.ok(string.format("Found executable: '%s'", exe))
    else
      vim.health.warn(string.format("Could not find executable: '%s'", exe))
    end
  end

  return true
end

return {
  check = function()
    vim.health.start 'kickstart.nvim'

    vim.health.info [[NOTE: Not every warning is a 'must-fix' in `:checkhealth`

  Fix only warnings for plugins and languages you intend to use.
    Mason will give warnings for languages that are not installed.
    You do not need to install, unless you want to use those languages!]]

    local uv = vim.uv or vim.loop
    vim.health.info('System Information: ' .. vim.inspect(uv.os_uname()))

    check_version()
    check_external_reqs()
  end,
}
</file>

<file path="memory-bank/docs/usage.md">
# Python Debugging System Usage Guide

## Quick Start

### Installation
1. Ensure dependencies:
   ```bash
   :PackerSync  # Install required plugins
   :checkhealth dap  # Verify setup
   ```

2. Framework Detection:
   ```lua
   -- Automatically detects Django/FastAPI projects
   -- Uses appropriate configuration
   ```

### Basic Usage

1. Start Debugging:
   ```
   :lua require('dap').continue()  -- F5
   ```

2. Debug Controls:
   - Step Over: F10
   - Step Into: F11
   - Step Out: Shift+F11
   - Toggle Breakpoint: F9

### Framework-Specific Features

1. Django Projects:
   ```lua
   -- Auto-configures Django settings
   -- Handles runserver debugging
   -- Manages environment variables
   ```

2. FastAPI Applications:
   ```lua
   -- Supports hot reload
   -- Configures PYTHONPATH
   -- Handles import time profiling
   ```

### Performance Monitoring

1. Basic Metrics:
   ```lua
   -- Import time tracking
   -- Memory usage monitoring
   -- Stack trace analysis
   ```

2. Profile Current File:
   ```lua
   -- Select "Python: Profile Current File"
   -- View metrics in DAP UI
   ```

## Troubleshooting

1. Common Issues:
   - Plugin specification errors: Run `:PackerSync`
   - Framework detection: Check project structure
   - Performance monitoring: Verify Python debugpy

2. Debug Log:
   ```lua
   :lua require('dap').set_log_level('DEBUG')
</file>

<file path="memory-bank/activeContext.md">
# Active Context

## Current Task
Fixing which-key plugin configuration

## Recent Changes
- Moved which-key configuration to dedicated keymaps.lua
- Implemented proper lazy.nvim plugin specification
- Added complete which-key configuration:
  - Base plugin options
  - Preset configurations
  - Window settings
  - Standard key group mappings

## Technical Details
- Using lazy.nvim's standard plugin format
- Proper event trigger with 'VeryLazy'
- Configured timeout settings
- Set up default mapping groups
- Maintained modular architecture

## Implementation Notes
- Moved from init.lua to lua/custom/plugins/keymaps.lua
- Added proper initialization timing
- Configured essential which-key features
- Maintained all standard key groups

## Next Steps
1. Test the configuration:
   ```lua
   nvim  -- Launch Neovim
   -- Press <leader> key to verify groups
   -- Test each mapping group
   ```
2. Consider adding project-specific mappings
3. Document key bindings in a reference guide

## Current Status
- Which-key configuration modularized
- Standard mapping groups defined
- Ready for testing
</file>

<file path="memory-bank/checkpoint.md">
# Checkpoint Documentation

**Timestamp:** 3/4/2025, 12:26 PM (UTC-3)

This document serves as a checkpoint capturing the current state of the project's architectural documentation. It aggregates the following:

- **Active Context:**  
  *Reference: [activeContext.md](activeContext.md)*  
  - Current work focus, recent changes, and next steps have been documented.

- **System Patterns:**  
  *Reference: [systemPatterns.md](systemPatterns.md)*  
  - Key architectural decisions, design patterns, and component relationships are defined.

- **Progress:**  
  *Reference: [progress.md](progress.md)*  
  - Current status, what is working, next steps, and known issues are recorded.

**Tag:** `#DOCUMENTATION_CHECKPOINT`

This checkpoint will serve as a baseline snapshot for future implementation tasks and iterative documentation updates.
</file>

<file path="memory-bank/productContext.md">
# Product Context

## Purpose
To create a comprehensive Neovim configuration with advanced debugging and testing capabilities, enabling efficient development workflows and robust code quality assurance.

## Problem Solution
- Streamlines debugging process with DAP integration
- Provides comprehensive testing framework
- Enables performance monitoring
- Facilitates memory usage analysis
- Integrates Git workflow management

## User Experience Goals
1. Development Workflow
   - Intuitive debugging experience
   - Seamless test execution
   - Quick performance analysis
   - Easy memory tracking
   - Efficient Git operations

2. Code Quality
   - Robust testing capabilities
   - Performance optimization
   - Memory leak detection
   - System resource monitoring
   - Git change management

3. Productivity Features
   - Quick file navigation
   - Efficient keybindings
   - Automated test runs
   - Integrated diagnostics
   - Streamlined Git workflows

## Key Benefits
- Enhanced debugging capabilities
- Comprehensive test coverage
- Performance optimization tools
- Memory analysis features
- System resource monitoring
- Integrated Git management
- Efficient code navigation
- Documented workflows
</file>

<file path="memory-bank/progress.md">
# Progress Report

## Completed Tasks
1. Reorganized which-key configuration:
   - Created dedicated keymaps.lua plugin module
   - Moved configuration out of init.lua
   - Implemented proper lazy.nvim spec

2. Configuration Improvements:
   - Added proper event triggering
   - Set up base plugin options
   - Configured preset features
   - Added window settings

3. Key Mapping Structure:
   - Defined standard mapping groups
   - Added proper mode settings
   - Maintained consistent naming
   - Organized by functionality

## Current Status
✅ Which-key configuration modularized
✅ Standard mapping groups defined
✅ Plugin setup properly configured
✅ Configuration follows lazy.nvim spec
✅ Documentation updated

## Next Steps
1. Testing:
   - Launch Neovim after changes
   - Verify which-key loads properly
   - Test all mapping groups
   - Check help functionality

2. Enhancements:
   - Add project-specific mappings
   - Create key bindings documentation
   - Consider adding mode-specific mappings
   - Implement task-specific bindings

## Known Issues
None - Previous which-key configuration issues resolved through modularization

## Dependencies
- which-key.nvim
- lazy.nvim (plugin manager)
- Neovim core
</file>

<file path="memory-bank/projectbrief.md">
# Neovim Configuration Project

## Core Requirements
- Advanced Neovim configuration with integrated debugging capabilities
- Comprehensive testing framework implementation
- Debug Adapter Protocol (DAP) integration
- Performance and memory testing tools
- Git workflow management

## Project Goals
- Create a robust, maintainable Neovim setup
- Implement extensive testing capabilities
- Provide debugging tools for development
- Enable automated test execution
- Streamline Git operations

## Scope
- Custom plugin configuration
- DAP framework implementation
- Test automation tooling
- System monitoring integration
- Performance analysis tools
- Git integration and workflows
- Keybinding management
- Documentation maintenance

## Key Features
- DAP support for debugging
- Test runner integration
- Memory analysis tools
- Performance monitoring
- Git operations support
- Telescope integration
- Which-key documentation
</file>

<file path="memory-bank/python-ide-analysis.md">
# Python IDE Configuration Analysis

## Overview
This document outlines the detailed analysis plan for the Python IDE configuration, focusing on integration and performance of the Python REPL, debugging settings, terminal output management, and UI customization options.

## Python REPL Integration & Performance
- **Benchmark Metrics:**
  - Startup time measurement
  - Memory consumption during initialization and usage
  - Command execution latency
- **Integration Analysis:**
  - Review configuration in `lua/custom/plugins/python-repl.lua`
  - Determine if the integration uses a dedicated extension or VSCode's built-in features
  - Evaluate performance-impacting parameters (e.g., auto-reload, caching)

## Debugging Settings & Development Efficiency
- **Configuration Review:**
  - Analyze VSCode's debugging settings (launch.json and DAP configuration via `lua/custom/plugins/dap.lua`)
  - Identify use of conditional breakpoints, log points, and custom debug adapters
- **Efficiency Recommendations:**
  - Propose optimization of debug log filtering to reduce noise
  - Suggest enabling/disabling specific debugging features based on development needs
  - Benchmark impacts on debug session performance and user efficiency

## Additional Features Enhancing the Coding Environment
- **Extension Compatibility:**
  - Review interoperability between the Python extension and additional tools like linters and formatters
- **Terminal Output Management:**
  - Assess VSCode terminal settings such as auto-scroll, font rendering, colorization, and output clarity
- **UI Customization Options:**
  - Analyze theming, layout, and panel arrangements for improved user experience
  - Document custom keymaps and UI tweaks applied via VSCode and Neovim lua configuration

## Workflow Diagram
```mermaid
flowchart TD
    A[Start Analysis] --> B[Review Python REPL Integration]
    B --> C[Measure Performance Benchmarks]
    C --> D[Identify REPL Configuration in lua/custom/plugins/python-repl.lua]
    A --> E[Analyze Debugging Settings]
    E --> F[Review launch.json / DAP settings]
    F --> G[Benchmark Debug Session Metrics & Assess Efficiency]
    A --> H[Evaluate Additional Features]
    H --> I[Extension Compatibility]
    H --> J[Terminal Output Management]
    H --> K[UI Customization Options]
    I --> L[Aggregate Findings]
    J --> L
    K --> L
    L --> M[Document Recommendations and Actionable Improvements]
```

## Next Steps
- Validate the benchmarks and recommendations noted above.
- Highlight actionable improvements and propose configuration adjustments based on the analysis.
- Use these findings to guide further optimization of the Python development environment.
- Implement documentation for shortcuts.
</file>

<file path="memory-bank/python-ide-suggestions.md">
# Python IDE Configuration Suggestions

This document builds on the analysis provided in [python-ide-analysis.md](python-ide-analysis.md) and outlines additional improvement suggestions:

## Python REPL Integration
- **Environment Isolation:**  
  • Implement virtual environment auto-detection and integration for seamless package management.  
  • Consider using lightweight REPL enhancements (e.g., IPython) to improve interactivity.

- **Performance Optimization:**  
  • Enable auto-reload settings with caution to balance responsiveness and resource usage.  
  • Benchmark REPL startup and runtime performance regularly, and adjust caching configurations as needed.

## Debugging Settings
- **Breakpoint Efficiency:**  
  • Utilize conditional and log breakpoints to decrease debugging noise.  
  • Optimize how breakpoints are managed to avoid performance drag in complex projects.

- **DAP and Configuration:**  
  • Fine-tune debug adapter parameters to minimize initialization delays.  
  • Regularly review and clean up outdated or redundant debug configurations in `lua/custom/plugins/dap.lua` and VSCode's launch configurations.

- **Integrated Tooling:**  
  • Consider enabling additional logging options during debugging sessions to guide troubleshooting, then disable them to boost performance.

## Terminal Output Management
- **Output Clarity:**  
  • Adjust settings for terminal font size, color schemes, and auto-scroll behavior to improve readability.  
  • Integrate terminal output filters to quickly parse and highlight error messages.

- **Performance Considerations:**  
  • Monitor terminal performance under heavy output loads and consider splitting long-running logs into paginated views or summarizing messages.

## UI Customization Options
- **Theme and Layout Consistency:**  
  • Maintain consistency between VSCode’s default theme and any custom UI tweaks applied in the Neovim Lua configurations.  
  • Experiment with panel configurations and customizable keymaps to optimize workspace usability.

- **User Experience Enhancements:**  
  • Solicit regular feedback from the user base to determine which UI elements can be further optimized.  
  • Introduce modular UI components that can be toggled on or off based on task requirements.

## Next Steps
- Regularly review configuration benchmarks and feedback loops to keep the IDE environment tuned for performance and efficiency.
- Implement A/B testing for experimental changes (e.g., different theme settings or breakpoint management techniques) to identify the most effective configurations.

These suggestions are aimed at continuously improving the development experience, ensuring that the Python environment remains responsive, efficient, and tailored to user needs.
</file>

<file path="memory-bank/systemPatterns.md">
# System Patterns

## Architecture Overview
- Modular plugin-based architecture
- Event-driven debugging system
- Layered test framework
- Configurable keymapping system
- Git integration framework

## Design Patterns
1. Plugin Management
   - Isolated plugin configurations
   - Lazy loading mechanism
   - Event-based communication
   - State management per plugin
   - Git operations handling

2. Debug Framework
   - DAP protocol implementation
   - Test runner integration
   - Performance monitoring
   - Memory tracking systems
   - Git debugging support

3. Testing Architecture
   - Unit test framework
   - Performance test suite
   - Memory usage tests
   - System integration tests
   - Git operation tests

## Component Relationships
- Core Neovim integration
- Plugin interdependencies
- Test framework layers
- Debug protocol handlers
- Git system integration

## Implementation Guidelines
- Maintain plugin isolation
- Follow event-driven patterns
- Implement proper error handling
- Support async operations
- Use lazy loading for plugins
- Centralize keybinding management
- Document Git workflows
</file>

<file path="memory-bank/techContext.md">
# Technical Context

## Core Technologies
- Primary Language: Lua
- Platform: Neovim
- Debug Framework: DAP (Debug Adapter Protocol)
- Git Integration: vim-fugitive

## Development Setup
- Modular plugin architecture
- Custom test framework integration
- Keybinding management system
- File tree and navigation tools
- Git workflow integration

## Dependencies
- Debug Adapter Protocol (DAP)
- Harpoon for navigation
- Custom test runners
- System monitoring tools
- vim-fugitive for Git operations
- Telescope for Git navigation
- Which-key for command documentation

## Technical Constraints
- Neovim compatibility requirements
- Lua language limitations
- Plugin integration boundaries
- Performance considerations
- Git command execution overhead

## Development Tools
- Visual Studio Code (for development)
- Integrated testing framework
- Built-in debugging tools
- Custom diagnostic utilities
- Git integration tools
- Which-key command documentation
</file>

<file path=".clinerules">
# Project Patterns and Rules
PLUGIN_PATH=lua/custom/plugins/
TEST_SUFFIX=_test.lua
DAP_PREFIX=dap_
FILE_STRUCTURE=Maintain modular plugin architecture in lua/custom/plugins/
TEST_TYPES=Separate test files by type (unit/perf/mem)
ASYNC_PATTERN=Use async handlers for debug operations
ERROR_HANDLING=Implement consistent error tracking and recovery
DOCUMENTATION=Keep memory bank updated with all significant changes
KEY_MAPS=Store custom keymaps in lua/custom/plugins/keymaps.lua
MONITOR=Implement system monitoring in separate modules
TEST_FRAMEWORK=Use modular test runner design
MEMORY_TRACKING=Separate memory analysis from main tests
</file>

<file path=".clinerules-architect">
mode: architect
instructions:
  general:
    - "Status Prefix: Begin EVERY response with either '[MEMORY BANK: ACTIVE]' or '[MEMORY BANK: INACTIVE]'"
    - >
      Memory Bank Management:
        1. **Check for Memory Bank:** Determine if memory-bank directory exists
        2. **If NO Memory Bank:**
           - Guide initialization process
           - Check for projectBrief.md in root
           - If projectBrief.md exists:
             * Read contents for context
           - If no projectBrief.md:
             * Prompt user for project info
             * Create projectBrief.md
           - Create memory-bank directory
           - Create and initialize core files:
             * activeContext.md
             * productContext.md
             * progress.md
             * decisionLog.md
             * systemPatterns.md
        3. **If Memory Bank Exists:**
           - Silently read ALL memory bank files
           - Verify core files exist
           - Initialize missing files if needed
           - Present project status summary
    - >
      File Authority:
        - You can ONLY create and modify markdown (*.md) files
        - READ access is allowed for all file types
        - For non-markdown changes:
          * Document needed changes
          * Switch to Code mode for implementation
          * Provide clear specifications
    - >
      Tool Usage Strategy:
        1. **Pre-execution Analysis:**
           - Document current state assessment
           - List affected files/components
           - Verify file type restrictions (*.md only)
           - Prepare fallback strategies
        2. **Tool Hierarchy:**
           - Primary: apply_diff for markdown files
             * Verify line counts match exactly
             * Confirm content matches
             * Use precise line numbers
           - Fallback: write_to_file (markdown only)
             * For new files
             * When apply_diff fails
             * For small files (< 100 lines)
        3. **Error Management:**
           - Preserve original content
           - Document validation failures
           - Provide clear error guidance
           - Use appropriate fallbacks
    - >
      Mode Collaboration Rules:
        1. Code Mode Integration:
           - Provide implementation specs
           - Review code architecture
           - Document design decisions
           - Track technical debt
           Handoff Triggers:
           * implementation_needed
           * code_modification_needed
           * refactoring_required

        2. Test Mode Partnership:
           - Define test requirements
           - Review coverage plans
           - Validate test strategies
           - Document quality goals
           Handoff Triggers:
           * needs_test_plan
           * requires_test_review
           * coverage_goals_undefined

        3. Debug Mode Support:
           - Review system issues
           - Guide investigations
           - Document resolutions
           - Update patterns
           Handoff Triggers:
           * architectural_issue_detected
           * design_flaw_detected
           * performance_problem_found

        4. Ask Mode Interaction:
           - Maintain documentation
           - Clarify architecture
           - Support knowledge base
           - Guide transitions
           Handoff Triggers:
           * needs_clarification
           * documentation_update_needed
           * knowledge_sharing_required
    - >
      Documentation Standards:
        1. Design Documentation:
           - Architecture overview
           - System patterns
           - Component relationships
           - Integration points

        2. Decision Records:
           - Context and background
           - Options considered
           - Selected approach
           - Implementation notes

        3. Task Management:
           - Clear specifications
           - Dependencies noted
           - Success criteria
           - Validation steps

        4. Knowledge Sharing:
           - Pattern documentation
           - Best practices
           - Design principles
           - Learning resources

  # UMB Section - Added to ALL modes
  umb:
    trigger: "^(Update Memory Bank|UMB)$"
    instructions:
      - "Halt Current Task: Stop current activity"
      - "Acknowledge Command: '[MEMORY BANK: UPDATING]'"
      - "Review Chat History"
      - "Update Memory Bank Files"
      - >
          Architecture Focus:
          - Design decisions
          - System patterns
          - Documentation structure
          - Implementation guidance
      - "Note: Override is TEMPORARY"
    override_file_restrictions: true

  memory_bank: {}
mode_triggers:
  code:
    - condition: implementation_needed
    - condition: code_modification_needed
    - condition: refactoring_required
  test:
    - condition: needs_test_plan
    - condition: requires_test_review
    - condition: coverage_goals_undefined
  debug:
    - condition: architectural_issue_detected
    - condition: design_flaw_detected
    - condition: performance_problem_found
  ask:
    - condition: needs_clarification
    - condition: documentation_update_needed
    - condition: knowledge_sharing_required
</file>

<file path=".clinerules-ask">
mode: ask
instructions:
  general:
    - "Status Prefix: Begin EVERY response with either '[MEMORY BANK: ACTIVE]' or '[MEMORY BANK: INACTIVE]'"
    - "Answer questions clearly and concisely."
    - "Handle both project-related and general questions."
    - >
      Access Rules:
        1. Default State:
           - READ-ONLY access to all files
           - Cannot create or modify files
           - Must direct changes to other modes
        2. UMB Override:
           - Triggered by user command ONLY
           - Can update memory-bank/*.md files
           - Access reverts after completion
    - >
      Memory Bank Interaction:
        1. **Check for Memory Bank:** Determine if a `memory-bank/` directory exists.
        2. **If NO Memory Bank:**
           - Answer the user's question directly if possible
           - Ask clarifying questions if needed
           - Ask if they would like to switch to Architect mode to initialize the Memory Bank
           - Use `switch_mode` tool to change to Architect mode if agreed
        3. **If Memory Bank Exists:**
           - Read ALL relevant Memory Bank files silently
           - Use information to provide context-aware answers
           - Check for missing core files:
             * activeContext.md
             * productContext.md
             * progress.md
             * decisionLog.md
             * systemPatterns.md
           - If any core files are missing, suggest Architect mode switch
    - >
      Tool Restrictions:
        - Can use read_file (reading)
        - Can use search_files (searching)
        - Can use list_files (directory listing)
        - Can use list_code_definition_names (code analysis)
        - Can use ask_followup_question (clarification)
        - Can use switch_mode (mode changes)
        - Can use new_task (task creation)
        - Can use write_to_file ONLY during UMB
    - >
      Guide users to appropriate modes:
        - Code mode for implementation
        - Architect mode for design
        - Debug mode for troubleshooting
        - Test mode for test coverage
    - "You are *not* responsible for maintaining the Memory Bank"
    - >
      Question Handling:
        1. Project Questions:
           - Read relevant files
           - Consider context
           - Direct decisions to proper modes
           - NO direct implementation
        2. General Questions:
           - Use domain knowledge
           - Not limited to project
           - Clear explanations
           - Technical accuracy
    - >
      Mode Switch Triggers:
        1. Implementation Decisions:
           - Switch to Code mode
           - Provide clear rationale
           - Document requirements
        2. Design Decisions:
           - Switch to Architect mode
           - Explain design needs
           - Note constraints
        3. Technical Issues:
           - Switch to Debug mode
           - Describe problem
           - List observations
        4. Test Requirements:
           - Switch to Test mode
           - Outline coverage needs
           - Note scenarios
    - >
      **CRITICAL:**
        - Do *not* display tool calls
        - NEVER modify files outside UMB
        - Always suggest mode switches
        - Maintain read-only status

  # UMB Section - Added to ALL modes
  umb:
    trigger: "^(Update Memory Bank|UMB)$"
    instructions:
      - "Halt Current Task: Stop all activity"
      - "Acknowledge Command: '[MEMORY BANK: UPDATING]'"
      - "Review Chat History"
      - >
          UMB Process Flow:
            1. When triggered:
               - Stop current activity
               - Analyze chat history
               - Identify key updates
            2. Available Actions:
               - CAN update memory-bank/*.md
               - CANNOT update other files
               - Must be explicit updates
            3. After Update:
               - Document changes made
               - Return to read-only
               - Continue prior task
      - >
          Update Format:
            - Use markdown formatting
            - Include context
            - Be specific and clear
            - Document reasoning
      - "Note: This override is TEMPORARY"
    override_file_restrictions: true  # Only during UMB process

  memory_bank: {}
mode_triggers:
  architect:
    - condition: needs_architectural_guidance
    - condition: design_question
    - condition: documentation_structure
  code:
    - condition: needs_implementation_guidance
    - condition: code_example_request
    - condition: feature_request
  debug:
    - condition: debugging_question
    - condition: error_explanation_request
    - condition: performance_issue
  test:
    - condition: needs_testing_explained
    - condition: requires_test_info
    - condition: coverage_question
</file>

<file path=".clinerules-code">
mode: code
instructions:
  general:
    - "Status Prefix: Begin EVERY response with either '[MEMORY BANK: ACTIVE]' or '[MEMORY BANK: INACTIVE]'"
    - "Implement features and maintain code quality"
    - >
      Memory Bank Maintenance:
        - **activeContext.md:** Track tasks, progress, and issues in real-time.
        - **progress.md:** Record completed work and update `Next Steps`. Use `progress.md` for task management (status, dependencies, scope).
        - **decisionLog.md:** Log implementation decisions as they are made.
        - **productContext.md:** Update implementation details as needed.
        - **systemPatterns.md:** Update if new patterns are used.
    - >
      File Authority:
        - Full access to all source code files
        - Read/write for code and configuration
        - Memory Bank updates during UMB only
    - >
      When a Memory Bank is found:
        1. Read ALL files in the memory-bank directory, one at a time, using the `read_file` tool and waiting for confirmation after each read.
        2. Check for core Memory Bank files:
            - activeContext.md
            - productContext.md
            - progress.md
            - decisionLog.md
        3. If any core files are missing:
            - Inform user about missing files
            - Briefly explain their purposes
            - Offer to create them
        4. Present available implementation tasks based on Memory Bank content
        5. Wait for user selection before proceeding
    - >
      If NO Memory Bank is found:
        - **Ask the user if they would like to switch to Architect mode to initialize the Memory Bank.**
        - Use the `ask_followup_question` tool for this
        - If the user agrees, use the `switch_mode` tool to switch to `architect`
        - If the user declines, proceed with the current task as best as possible without a Memory Bank
    - >
      Mode Collaboration Rules:
        1. Architect Mode Integration:
           - Receive design specifications
           - Implement architectural patterns
           - Request design guidance
           - Report implementation blocks
           Handoff Triggers TO Architect:
           * needs_architectural_changes
           * design_clarification_needed
           * pattern_violation_found
           Handoff Triggers FROM Architect:
           * implementation_needed
           * code_modification_needed
           * refactoring_required

        2. Test Mode Partnership:
           - Implement test requirements
           - Fix test failures
           - Update affected tests
           - Maintain test coverage
           Handoff Triggers TO Test:
           * tests_need_update
           * coverage_check_needed
           * feature_ready_for_testing
           Handoff Triggers FROM Test:
           * test_fixes_required
           * coverage_gaps_found
           * validation_failed

        3. Debug Mode Support:
           - Implement fixes
           - Update error handling
           - Apply performance fixes
           - Document changes
           Handoff Triggers TO Debug:
           * error_investigation_needed
           * performance_issue_found
           * system_analysis_required
           Handoff Triggers FROM Debug:
           * fix_implementation_ready
           * performance_fix_needed
           * error_pattern_found

        4. Ask Mode Interaction:
           - Explain implementations
           - Document code changes
           - Clarify patterns
           - Share knowledge
           Handoff Triggers TO Ask:
           * documentation_needed
           * implementation_explanation
           * pattern_documentation
           Handoff Triggers FROM Ask:
           * clarification_received
           * documentation_complete
           * knowledge_shared
    - >
      Implementation Standards:
        1. Code Quality:
           - Follow project patterns
           - Maintain clean code
           - Error handling
           - Performance aware

        2. Documentation:
           - Code comments
           - Implementation notes
           - Change records
           - Usage examples

        3. Testing:
           - Unit tests
           - Integration tests
           - Coverage goals
           - Regression tests

        4. Error Handling:
           - Proper catching
           - Clear messages
           - Recovery paths
           - Logging

  # UMB Section - Added to ALL modes
  umb:
    trigger: "^(Update Memory Bank|UMB)$"
    instructions:
      - "Halt Current Task: Stop current activity"
      - "Acknowledge Command: '[MEMORY BANK: UPDATING]'"
      - "Review Chat History"
      - >
          Code Focus Updates:
          - Implementation details
          - Code patterns used
          - Technical decisions
          - Test coverage
      - "Note: Override is TEMPORARY"
    override_file_restrictions: true

  memory_bank: {}
mode_triggers:
  architect:
    - condition: needs_architectural_changes
    - condition: design_clarification_needed
    - condition: pattern_violation_found
  test:
    - condition: tests_need_update
    - condition: coverage_check_needed
    - condition: feature_ready_for_testing
  debug:
    - condition: error_investigation_needed
    - condition: performance_issue_found
    - condition: system_analysis_required
  ask:
    - condition: documentation_needed
    - condition: implementation_explanation
    - condition: pattern_documentation
</file>

<file path=".clinerules-debug">
mode: debug
instructions:
  general:
    - "Status Prefix: Begin EVERY response with either '[MEMORY BANK: ACTIVE]' or '[MEMORY BANK: INACTIVE]'"
    - >
      Memory Bank Initialization:
        1. **Check for Memory Bank:** Determine if memory-bank directory exists.
        2. **If NO Memory Bank:**
           - Ask if user wants to switch to Architect mode to initialize
           - Use ask_followup_question for the prompt
           - Switch to Architect mode if agreed using switch_mode
           - Otherwise proceed with limited context
        3. **If Memory Bank Exists:**
           - Silently read ALL memory bank files
           - Check for core files:
             * activeContext.md
             * productContext.md
             * progress.md
             * decisionLog.md
           - If any core files missing, suggest Architect mode switch
    - >
      Access Rules:
        1. Default State:
           - READ access to all files
           - Execute diagnostic commands
           - No file modifications
           - Must defer changes to other modes
        2. UMB Override:
           - Triggered by user command ONLY
           - Can update memory-bank/*.md files
           - Access reverts after completion
    - >
      Diagnostic Process:
        1. Initial Analysis (Consider 5-7 possibilities):
           - Error patterns
           - System state
           - Recent changes
           - Configuration issues
           - External dependencies
           - Resource constraints
           - Code patterns
        2. Root Cause Focus (Narrow to 1-2):
           - Evidence analysis
           - Pattern matching
           - Impact assessment
           - Confidence level
        3. Validation Steps:
           - Add diagnostic logs
           - Run targeted tests
           - Monitor behavior
           - Document findings
        4. Confirmation:
           - Present findings to user
           - Get diagnosis confirmation
           - Plan fix strategy
           - Switch to appropriate mode
    - >
      Mode Collaboration:
        1. Code Mode Handoff:
           - Document exact fix needed
           - List affected components
           - Note potential risks
           - Suggest validation tests
        2. Architect Mode Consultation:
           - For design-level issues
           - Pattern-related problems
           - Structural concerns
           - Documentation gaps
        3. Ask Mode Support:
           - Historical context
           - Similar issues
           - Documentation review
           - Knowledge sharing
        4. Test Mode Integration:
           - Test failure analysis
           - Coverage gaps
           - Validation plans
           - Regression prevention
    - >
      Documentation Requirements:
        1. Problem Description:
           - Error details
           - System context
           - Reproduction steps
           - Impact assessment
        2. Analysis Process:
           - Methods used
           - Tools applied
           - Findings made
           - Evidence gathered
        3. Root Cause:
           - Core issue
           - Contributing factors
           - Related patterns
           - Supporting evidence
        4. Fix Requirements:
           - Proposed changes
           - Validation needs
           - Risk factors
           - Success criteria
    - >
      Memory Bank Usage:
        1. activeContext.md:
           - Current debugging focus
           - Recent investigations
           - Key findings
           - Open questions
        2. progress.md:
           - Investigation steps
           - Validation attempts
           - Next actions
           - Dependencies
        3. decisionLog.md:
           - Analysis decisions
           - Tool choices
           - Fix strategies
           - Mode transitions
        4. systemPatterns.md:
           - Error patterns
           - Debug techniques
           - Solution patterns
           - Validation methods
    - >
      Tool Restrictions:
        - Can use read_file
        - Can use search_files
        - Can use list_files
        - Can use list_code_definition_names
        - Can use execute_command
        - Can use ask_followup_question
        - Can use write_to_file ONLY during UMB
        - CANNOT modify project files
    - "CRITICAL: Must get user confirmation of diagnosis before suggesting fixes"

  # UMB Section - Added to ALL modes
  umb:
    trigger: "^(Update Memory Bank|UMB)$"
    instructions:
      - "Halt Current Task: Stop all activity"
      - "Acknowledge Command: '[MEMORY BANK: UPDATING]'"
      - "Review Chat History"
      - >
          UMB Process Flow:
            1. When triggered:
               - Stop current activity
               - Analyze debug history
               - Identify key findings
            2. Available Actions:
               - CAN update memory-bank/*.md
               - CANNOT update other files
               - Must document clearly
            3. After Update:
               - Document changes made
               - Return to read-only
               - Continue debugging
      - >
          Debug-Specific Updates:
            - Document error patterns
            - Log investigation steps
            - Track root causes
            - Note validation results
      - "Note: This override is TEMPORARY"
    override_file_restrictions: true  # Only during UMB process

  memory_bank: {}
mode_triggers:
  architect:
    - condition: needs_architectural_review
    - condition: pattern_indicates_design_issue
  code:
    - condition: fix_implementation_needed
    - condition: performance_fix_required
  ask:
    - condition: needs_context_clarification
    - condition: documentation_review_needed
  test:
    - condition: test_validation_needed
    - condition: coverage_assessment_required
</file>

<file path=".clinerules-test">
mode: test
instructions:
  general:
    - "Status Prefix: Begin EVERY response with either '[MEMORY BANK: ACTIVE]' or '[MEMORY BANK: INACTIVE]'"
    - "Follow Test-Driven Development (TDD) principles"
    - >
      Memory Bank Interaction:
        1. **Check for Memory Bank:** Determine if memory-bank directory exists.
        2. **If NO Memory Bank:**
           - Answer the user's question directly if possible
           - Ask clarifying questions if needed
           - Suggest switching to Architect mode to initialize Memory Bank
           - Use switch_mode tool if user agrees
        3. **If Memory Bank Exists:**
           - Silently read ALL memory bank files
           - Check for core files:
             * activeContext.md
             * productContext.md
             * progress.md
             * decisionLog.md
             * systemPatterns.md
           - If any core files missing, suggest Architect mode switch
    - >
      Access Rules:
        1. Default State:
           - READ access to all files
           - Can execute test commands
           - NO file modifications
           - Must defer changes to other modes
        2. UMB Override:
           - Triggered by user command ONLY
           - Can update memory-bank/*.md files
           - Access reverts after completion
    - >
      Testing Process:
        1. Requirements Phase:
           - Get requirements from Architect
           - Clarify with Ask mode
           - Create test strategy
           - Get plan approval
        2. Test Development:
           - Write test cases
           - Document coverage goals
           - Set success criteria
           - Note dependencies
        3. Test Execution:
           - Run test suite
           - Document results
           - Track coverage
           - Report status
        4. Failure Handling:
           - Document failures clearly
           - Create bug reports
           - Switch to Debug mode
           - Track resolutions
    - >
      Mode Collaboration:
        1. Architect Mode:
           - Get test requirements
           - Review test strategy
           - Validate coverage plans
           - Update documentation
        2. Code Mode:
           - Share test specifications
           - Verify implementations
           - Request test fixes
           - Document changes
        3. Debug Mode:
           - Report test failures
           - Share test context
           - Track investigations
           - Validate fixes
        4. Ask Mode:
           - Clarify requirements
           - Review test plans
           - Document patterns
           - Share knowledge
    - >
      Documentation Requirements:
        1. Test Plans:
           - Test strategy
           - Test cases
           - Coverage goals
           - Dependencies
        2. Test Results:
           - Test runs
           - Pass/fail status
           - Coverage metrics
           - Issues found
        3. Bug Reports:
           - Clear description
           - Test context
           - Expected results
           - Actual results
        4. Handoff Notes:
           - Mode transitions
           - Context sharing
           - Action items
           - Follow-ups
    - >
      Tool Restrictions:
        - Can use read_file (reading)
        - Can use search_files (coverage)
        - Can use list_files (test suites)
        - Can use list_code_definition_names
        - Can use execute_command (tests)
        - Can use ask_followup_question
        - Can use switch_mode (mode changes)
        - Can use write_to_file ONLY during UMB
        - CANNOT modify project files
    - "CRITICAL: Must get Architect approval for test strategy changes"

  # UMB Section - Added to ALL modes
  umb:
    trigger: "^(Update Memory Bank|UMB)$"
    instructions:
      - "Halt Current Task: Stop all activity"
      - "Acknowledge Command: '[MEMORY BANK: UPDATING]'"
      - "Review Chat History"
      - >
          UMB Process Flow:
            1. When triggered:
               - Stop current activity
               - Analyze test results
               - Identify key findings
            2. Available Actions:
               - CAN update memory-bank/*.md
               - CANNOT update other files
               - Must document clearly
            3. After Update:
               - Document changes made
               - Return to read-only
               - Continue testing
      - >
          Test-Specific Updates:
            - Document test results
            - Log coverage metrics
            - Track test plans
            - Note failures
      - "Note: This override is TEMPORARY"
    override_file_restrictions: true  # Only during UMB process

  memory_bank: {}
mode_triggers:
  architect:
    - condition: needs_test_strategy
    - condition: coverage_goals_undefined
  code:
    - condition: tests_ready_for_implementation
    - condition: test_fixes_needed
  debug:
    - condition: test_failure_analysis
    - condition: unexpected_test_results
  ask:
    - condition: test_requirement_question
    - condition: test_case_clarification
</file>

<file path=".gitignore">
tags
test.sh
.luarc.json
nvim

spell/
lazy-lock.json
</file>

<file path=".roomodes">
{
  "customModes": [
    {
      "slug": "test",
      "name": "Test",
      "roleDefinition": "You are Roo's Test mode, responsible for test-driven development, test execution, and quality assurance. You write test cases before implementation, validate code against requirements, analyze test results, and coordinate with other modes for fixes. You collaborate with Architect mode for test strategy, Code mode for implementation, Debug mode for failures, and Ask mode for clarification. You have READ access to all files, can execute tests, and can update Memory Bank during UMB commands.",
      "groups": [
        "read",
        "browser",
        "command"
      ],
      "source": "project"
    }
  ]
}
</file>

<file path=".stylua.toml">
column_width = 160
line_endings = "Unix"
indent_type = "Spaces"
indent_width = 2
quote_style = "AutoPreferSingle"
call_parentheses = "None"
</file>

<file path="developer-primer.md">
# Roo Code Memory Bank: Developer Primer

## 🏗️ System Architecture

### Core Components

```mermaid
flowchart TD
    A[Memory Bank System] --> B[Core Files]
    A --> C[Mode System]
    A --> D[Configuration]
    A --> E[Real-time Updates]
    
    B --> B1[activeContext.md]
    B --> B2[productContext.md]
    B --> B3[progress.md]
    B --> B4[decisionLog.md]
    
    C --> C1[Architect Mode]
    C --> C2[Code Mode]
    C --> C3[Ask Mode]
    C --> C4[Debug Mode]
    
    D --> D1[.clinerules Files]
    D --> D2[Mode Switching]
    D --> D3[Tool Access]
    
    E --> E1[Event Monitor]
    E --> E2[Update Queue]
    E --> E3[Sync Manager]
```

## 📚 Memory Bank Structure

The Memory Bank system consists of a `memory-bank/` directory containing core and optional files:


### Core Files

1. **activeContext.md**
   - Purpose: Tracks current session state and goals
   - Content:
     - Current tasks and objectives
     - Recent changes and decisions
     - Open questions and blockers
     - Session-specific context
   - Update Frequency: Every session

2. **productContext.md**
   - Purpose: Defines project scope and core knowledge
   - Content:
     - Project overview and goals
     - Component architecture
     - Technical standards
     - Key dependencies
   - Update Frequency: When project scope changes

3. **progress.md**
   - Purpose: Tracks work status and milestones
   - Content:
     - Completed work items
     - Current tasks
     - Next steps
     - Known issues
   - Update Frequency: As tasks progress

4. **decisionLog.md**
   - Purpose: Records important decisions
   - Content:
     - Technical decisions
     - Architecture choices
     - Implementation details
     - Alternative considerations
   - Update Frequency: When decisions are made


## 🔄 Mode System

### Mode Types

1. **Architect Mode**
   - Purpose: System design and architecture
   - Capabilities:
     - Memory Bank initialization
     - Architecture decisions
     - System planning
   - File Access: Markdown files only

2. **Code Mode**
   - Purpose: Implementation and coding
   - Capabilities:
     - Full file access
     - Code generation
     - File modifications
   - No file restrictions

3. **Ask Mode**
   - Purpose: Information and guidance
   - Capabilities:
     - Context understanding
     - Documentation help
     - Best practices guidance
   - File Access: Read-only

4. **Debug Mode**
   - Purpose: Troubleshooting and problem-solving
   - Capabilities:
     - System behavior analysis
     - Incremental testing
     - Root cause identification
     - Diagnostic tooling
   - File Access: Read-only

### Intelligent Mode Switching

```mermaid
stateDiagram-v2
    Architect --> Code : Implementation/File Edit
    Architect --> Ask : Information Request
    Architect --> Debug : Problem Investigation
    Ask --> Code : Implementation Request
    Ask --> Architect : Design Discussion
    Ask --> Debug : Troubleshooting Request
    Code --> Architect : Architecture Review
    Code --> Ask : Documentation Help
    Code --> Debug : Bug Investigation
    Debug --> Code : Fix Implementation
    Debug --> Ask : Documentation Reference
    Debug --> Architect : System Design Review
```

The system supports intelligent mode switching based on both prompt analysis and operational needs:

1. **Intent-Based Triggers**:
   ```yaml
   mode_switching:
     enabled: true
     preserve_context: true
     intent_triggers:
         code:
           - implement
           - create
           - build
           - code
           - develop
           - fix
         debug:
           - debug
           - troubleshoot
           - diagnose
           - investigate
           - analyze
           - trace
           - root cause
         architect:
           - design
           - architect
           - structure
           - plan
         ask:
           - explain
           - help
           - what
           - how
           - why
   ```

2. **Operational Triggers**:
   - **File-based**: Switches based on file operations
   - **Mode-specific**: Contextual switches based on task type
   - **Capability-based**: Switches to mode with required capabilities

3. **Context Preservation**:
   - Maintains task state across switches
   - Preserves conversation history
   - Tracks active files and operations

4. **Benefits**:
   - Natural language-driven mode selection
   - Seamless context transitions
   - Improved workflow efficiency
   - Task-appropriate mode selection


## ⚙️ Configuration System

### .clinerules Files

1. **.clinerules-architect**
   - Mode switching for non-markdown files
   - Memory Bank initialization rules
   - Architecture documentation standards

2. **.clinerules-code**
   - Full file access configuration
   - Code generation settings
   - Tool access permissions

3. **.clinerules-ask**
   - Read-only access settings
   - Mode switching for edits
   - Documentation preferences

4. **.clinerules-debug**
   - Read-only access settings
   - Diagnostic tool permissions
   - Logging and tracing configurations

### File Organization

```
project-root/
├── .clinerules-architect
├── .clinerules-code
├── .clinerules-ask
├── .clinerules-debug
├── memory-bank/
│   ├── activeContext.md
│   ├── productContext.md
│   ├── progress.md
│   └── decisionLog.md
└── projectBrief.md
```

## 🛠️ Development Workflow

### Real-time Update System

1. **Event Monitoring**
   - Continuous tracking of project-related events
   - Mode-specific update triggers
   - Automatic event classification

2. **Update Processing**
   - Immediate file updates based on event type
   - Asynchronous processing for performance
   - Priority-based update queue

3. **Sync Management**
   - Cross-reference preservation
   - Context consistency checks
   - Conflict resolution

4. **Manual Fallback (UMB)**
   - Emergency session termination
   - Mid-task interruptions
   - Connection recovery
   - Force synchronization

### Memory Bank Initialization

1. Start in Architect mode
2. System checks for `memory-bank/`
3. If missing:
   - Creates directory
   - Generates core files
   - Sets up initial context

### Session Workflow

1. **Session Start**
   - System reads all Memory Bank files
   - Builds comprehensive context
   - Loads mode-specific rules

2. **During Session**
   - Automatic mode switching as needed
   - Context updates in activeContext.md
   - Progress tracking in progress.md

3. **Session End**
   - Update progress.md
   - Record decisions in decisionLog.md
   - Plan next steps

## 🔍 Best Practices

1. **Memory Bank Management**
   - Keep files focused and organized
   - Update regularly during sessions
   - Cross-reference between files

2. **Mode Usage**
   - Start architecture work in Architect mode
   - Let automatic switching handle transitions
   - Use Ask mode for documentation

3. **Documentation**
   - Keep decisions documented
   - Update progress regularly
   - Maintain clear context

## 🐛 Troubleshooting

1. **Mode Switching Issues**
   - Verify .clinerules files
   - Check file permissions
   - Review mode switching logs

2. **Memory Bank Problems**
   - Ensure core files exist
   - Verify file structure
   - Check file permissions

3. **Context Issues**
   - Update activeContext.md
   - Review recent changes
   - Check file synchronization


Example Memory Bank Updates:


* productContext.md:
 ```markdown
 # memory-bank/productContext.md

 Project Overview
 This project is a [briefly describe your application - e.g., "task management web application"].
 We are adding user authentication to enhance security and personalize user experience.

 Key Technologies
 - [List existing technologies]
 - OAuth 2.0 (for social login - *Decision needed: which provider?*)
 - JWT (JSON Web Tokens) for session management
 - bcrypt (for password hashing)
 ```

* activeContext.md (Example - Initial state):
 ```markdown
 # memory-bank/activeContext.md

 Current Task
 Developing user authentication feature.

 Next Steps
 - 1. Plan database schema for user credentials.
 - 2. Implement user registration API endpoint.
 - 3. Implement user login API endpoint.
 - 4. Implement JWT-based authentication middleware.

 Open Questions
 - Which OAuth 2.0 provider to use (Google, GitHub, etc.)?
 - Password complexity requirements?
 - Session management strategy (e.g., refresh tokens)?
 ```

* progress.md (Example - Tracking progress):
 ```markdown
 # memory-bank/progress.md

 Work Done
 - [Initially empty]
 - [After completing database schema design]: - Database schema for user credentials designed and documented.
 - [After implementing registration API]: - User registration API endpoint implemented and tested (basic functionality).
 - [Continue updating as tasks are completed]

 To Do
 - [Initially, list all planned tasks]
 - Plan database schema for user credentials.
 - Implement user registration API endpoint.
 - Implement user login API endpoint.
 - Implement JWT-based authentication middleware.
 - Implement frontend integration for login/registration.
 - Implement session management.
 - Implement password reset functionality.
 - Write unit and integration tests for authentication.
 - [Update as tasks are completed and new tasks emerge]

 Current Status
 User authentication feature - In development - Database schema design in progress.
 - [Update status as development progresses] - User authentication feature - In development - User registration API implemented, working on login API.
 - [Upon completion] - User authentication feature - Completed and integrated.
 ```

Benefits:

- Comprehensive feature planning & documentation
- Systematic task & progress tracking
- Context maintenance across sessions
- Effective status communication

Memory Bank for Refactoring: Complex Code Module

Memory Bank Initialization: Quick Workflow

The Memory Bank initialization is largely automatic. Here’s a simplified view of the process:

1. **Start in Architect or Code Mode:** When you open a new project in VS Code and switch to Architect or Code mode, Roo Code automatically checks for a `memory-bank/`.
2. **Initialization Plan:** If `memory-bank/` is missing, Roo Code (in Architect mode) will guide you with a plan to set it up.
3. **Switch to Code Mode:** Follow Roo's prompt to switch to Code mode.
4. **Create Memory Bank Files:** In Code mode, follow Roo's plan to create the `memory-bank/` directory and the necessary files.
5. **Memory Bank Ready:** Once files are created, your Memory Bank is initialized and ready for use.


Handling Multiple Projects in a Workspace


If you have multiple projects with their own Memory Banks within your VS Code workspace, Roo Code can automatically detect them and prompt you to select the target project for the current chat session.

Handling Multiple Projects in a Workspace


If you have multiple projects with their own Memory Banks within your VS Code workspace, Roo Code can automatically detect them and prompt you to select the target project for the current chat session.


Automatic Project Detection and Selection:


1. New Chat Session: When you start a new chat session in Architect or Code mode, Roo Code scans your workspace for `memory-bank/` directories.
2. Multiple Memory Banks Found: If multiple `memory-bank/` directories are detected, Roo Code will display a prompt in the chat asking you to choose the project you want to work on.
3. Project Selection Prompt: Roo Code will display a prompt asking you to choose your project.  It will look something like this in the chat:

```text
Multiple Memory Banks detected.

Please select the project for this session:

1. poptools-app
2. Roo-Code
3. roo-code-memory-bank

Enter the number of your project choice.
```
4. Select Your Project: Enter the number corresponding to the project you want to work with and press Enter.
5. Context Loaded: Roo Code will then load the Memory Bank for the selected project and use it for the current chat session.

Example Scenario: Multi-Project Workspace

Let's say you have a workspace with multiple projects, like `webapp` and `mobile-app`, each with its own `memory-bank/` directory.

When you initiate a new chat in Architect mode, Roo Code will detect both Memory Banks and ask you to select the project you want to focus on for this session. The prompt will look similar to the example below:

```text
Multiple Memory Banks detected.

Please select the project for this session:

1. webapp
2. mobile-app

Enter the number of your project choice.
```
By choosing '1', Roo Code will then use the Memory Bank from your `webapp` project for this session.

By selecting '1', you ensure that Roo Code uses the Memory Bank from your `webapp` project for this session.


Organizing Multi-Project Workspaces:


To effectively manage multiple projects with Memory Banks:

* Keep Memory Banks at Project Roots: Ensure each project has its `memory-bank/` directory at the root level of its project directory.
* Clear Project Names: Use descriptive names for your project directories to easily identify them in the project selection prompt.
* Workspace Structure: Organize your workspace so that project directories are clearly separated.

This automatic project detection and selection feature simplifies working with multiple projects and ensures Roo Code always has the correct project context for each session.


Automatic Project Detection and Selection:


1. New Chat Session: When you start a new chat session in Architect or Code mode, Roo Code scans your workspace for `memory-bank/` directories.
2. Multiple Memory Banks Found: If multiple `memory-bank/` directories are detected, Roo Code will display a prompt in the chat asking you to choose the project you want to work on.
3. Project Selection Prompt: Roo Code will display a prompt asking you to choose your project.  It will look something like this in the chat:

```text
Multiple Memory Banks detected.

Please select the project for this session:

1. poptools-app
2. Roo-Code
3. roo-code-memory-bank

Enter the number of your project choice.
```
4. Select Your Project: Enter the number corresponding to the project you want to work with and press Enter.
5. Context Loaded: Roo Code will then load the Memory Bank for the selected project and use it for the current chat session.

Example Scenario: Multi-Project Workspace

Let's say you have a workspace with multiple projects, like `webapp` and `mobile-app`, each with its own `memory-bank/` directory.

When you initiate a new chat in Architect mode, Roo Code will detect both Memory Banks and ask you to select the project you want to focus on for this session. The prompt will look similar to the example below:

```text
Multiple Memory Banks detected.

Please select the project for this session:

1. webapp
2. mobile-app

Enter the number of your project choice.
```
By choosing '1', Roo Code will then use the Memory Bank from your `webapp` project for this session.

By selecting '1', you ensure that Roo Code uses the Memory Bank from your `webapp` project for this session.


Organizing Multi-Project Workspaces:


To effectively manage multiple projects with Memory Banks:

* Keep Memory Banks at Project Roots: Ensure each project has its `memory-bank/` directory at the root level of its project directory.
* Clear Project Names: Use descriptive names for your project directories to easily identify them in the project selection prompt.
* Workspace Structure: Organize your workspace so that project directories are clearly separated.

This automatic project detection and selection feature simplifies working with multiple projects and ensures Roo Code always has the correct project context for each session.

Example Memory Bank Updates:


* activeContext.md (Refactoring plan & progress):
 ```markdown
 # memory-bank/activeContext.md

 Current Task
 Refactoring complex `utils/legacy_module.py` module.

 Refactoring Strategy
 - 1. Analyze `utils/legacy_module.py`
 - 2. Decompose into smaller modules/functions
 - 3. Improve naming and documentation
 - 4. Write unit tests
 - 5. Gradually refactor and test

 Files to Refactor
 - `utils/legacy_module.py`

 Refactoring Progress
 - [Initially empty]
 - [After analysis]: - Analysis of `utils/legacy_module.py` completed. Refactoring strategy documented.
 - [After decomposition]: - Core functions decomposed into smaller modules in `utils/refactored_module/`.
 - [Continue updating as refactoring progresses]

 Open Questions
 -  Dependencies on `utils/legacy_module.py`?
 -  Estimated refactoring time?
 ```

* decisionLog.md (Example decisions):
 ```markdown
 # memory-bank/decisionLog.md

 Refactoring `utils/legacy_module.py` - Decisions

 - [Date]: Decision: Decompose `legacy_module.py` by functional areas.
  - Rationale: Improves modularity and maintainability.
  - Alternatives: In-place refactoring (Rejected - less impactful).

 - [Date]: Decision: Use descriptive naming and comprehensive docstrings.
  - Rationale: Improves code readability.
  - Alternatives: Minimal documentation (Rejected - insufficient).
 ```

* progress.md (Tracking refactoring progress):
 ```markdown
 # memory-bank/progress.md

 Work Done
 - [Initially empty]
 - [After analysis and planning]: - Refactoring plan for `utils/legacy_module.py` documented in `activeContext.md` and `decisionLog.md`.
 - [After decomposition]: - Core functions of `legacy_module.py` decomposed into smaller modules in `utils/refactored_module/`.
 - [Continue updating as refactoring progresses]

 To Do
 - [Initially, list all refactoring tasks]
 - Analyze `utils/legacy_module.py`.
 - Decompose into smaller modules/functions.
 - Improve naming and documentation.
 - Write unit tests for refactored modules.
 - Gradually refactor and test each module.
 - Integrate refactored modules.
 - Verify functionality after refactoring.
 - [Update as tasks are completed]

 Current Status
 Refactoring `utils/legacy_module.py` - Planning complete.
 - [Update status as refactoring progresses] - Refactoring `utils/legacy_module.py` - In progress - Core functions decomposition completed.
 - [Upon completion] - Refactoring `utils/legacy_module.py` - Completed and verified.
 ```

Benefits:

- Systematic refactoring planning & management
- Documented strategy, decisions, & progress
- Context & open question tracking
- Improved team collaboration

Memory Bank for Bug Fixing: User Login Bug


Example Memory Bank Updates:


* activeContext.md (Bug investigation & details):
 ```markdown
 # memory-bank/activeContext.md

 Current Task
 Debugging user login bug.

 Bug Details
 - Symptom: Login redirects back with "Invalid credentials" error.
 - Reported by: Users (support tickets #123, #124, #125).
 - Affected users: All users.
 - Environment: All browsers/platforms.
 - Last working version: v1.2.0 (suspect v1.2.1 regression).

 Reproduction Steps
 1. Go to login page.
 2. Enter valid username and password.
 3. Submit login form.
 4. Observe "Invalid credentials" error.

 Investigation Progress
 - [Initially empty]
 - [After investigation]: - Server logs OK. `auth/login.py` code review - OK, need debugger.
 - [Next step]: - Debug login process.
 ```

* decisionLog.md (Debugging decisions & findings):
 ```markdown
 # memory-bank/decisionLog.md

 Bug Fix - User Login Bug - Decisions

 - [Date]: Decision: Debugged `auth/login.py` - password hashing.
  - Findings: Password hashing logic correct, password comparison fails.

 - [Date]: Decision: Investigate password comparison & bcrypt version.
  - Rationale: Suspect bcrypt incompatibility.
  - Action: Revert bcrypt version (quick verification).

 - [Date]: Decision: Reverted bcrypt. Login - working.
  - Findings: Reverting bcrypt fixed bug. Confirms bcrypt issue.
  - Next Steps: Document bcrypt issue, long-term fix.
 ```

* progress.md (Bug fix progress):
 ```markdown
 # memory-bank/progress.md

 Work Done
 - [Initially empty]
 - [After initial investigation]: - User login bug documented in `activeContext.md`. Debugging started.
 - [After identifying bcrypt issue]: - Root cause: bcrypt incompatibility. Temporary fix: bcrypt version revert.

 To Do
 - [Initially, bug fix tasks]
 - Investigate user login bug.
 - Identify root cause.
 - Implement temp fix (bcrypt revert).
 - Verify temp fix.
 - Investigate long-term bcrypt solution.
 - Implement long-term fix.
 - Regression tests.
 - Deploy fix.
 - Monitor login.
 - [Update tasks as needed]

 Current Status
 User login bug - Investigating - Root cause identified (bcrypt incompatibility). Temporary fix implemented/verified.
 - [Update status as bug fix progresses] - User login bug - Fix implemented and verified. - Temporary fix deployed. Monitoring.
 - [Upon completion] - User login bug - Fixed (long-term solution implemented). - Long-term fix deployed. Regression tests added.
 ```

Benefits:

- Systematic debugging
- Documented bug details & decisions
- Bug fix progress tracking
- Context maintenance during debugging
- Facilitated knowledge sharing

Troubleshooting


`[MEMORY BANK: ACTIVE]` Prefix Not Working


Solution: Check Custom Instructions
1. Verify custom instruction settings in VS Code: Ensure all custom instruction modules are correctly configured in "Roo Code Prompts" settings, especially "Mode-specific Custom Instructions/Code".
 * Detailed Verification Checklist:
  - [ ] **Global Instructions:** Verify that you have copied the *entire content* of the file `roo-code-memory-bank/custom-instructions/global-instructions.md` and pasted it into the "Global Instructions" setting within the "Roo Code Prompts" section in VS Code settings.
  - [ ] **Mode-specific Instructions/Architect:** Verify that you have copied the *entire content* of `roo-code-memory-bank/custom-instructions/mode-arch.md` and pasted it into the "Mode-specific Instructions/Architect" setting.
  - [ ] **Mode-specific Instructions/Ask:** Verify that you have copied the *entire content* of `roo-code-memory-bank/custom-instructions/mode-ask.md` and pasted it into the "Mode-specific Instructions/Ask" setting.
  - [ ] **Mode-specific Instructions/Code:** **Crucially**, verify that you have copied the *entire content* of `roo-code-memory-bank/custom-instructions/mode-code.md` and pasted it into the "Mode-specific Custom Instructions/Code" setting. **This specific setting is essential for the `[MEMORY BANK: ACTIVE]` prefix to function correctly in Code mode.**
 * Content Integrity: Double-check that you have copied the *complete content* of *each* specified file and pasted it into the *corresponding* settings area, ensuring no content was missed or corrupted during the copy-paste process.
2. Save Settings: Verify that VS Code settings were saved after pasting instructions.
3. Confirm Code Mode: Ensure you are in "Code" mode when using `[MEMORY BANK: ACTIVE]` prefix (check Roo Code chat interface).
4. Check Prefix Syntax: Verify exact syntax: `[MEMORY BANK: ACTIVE]` (case-sensitive, spacing).


Memory Bank Not Persisting After VS Code Restart


Solution:
1. Verify Memory Bank Initialization: Confirm that you have initiated the Memory Bank initialization process by switching to Architect mode in a new project (see "Getting Started" section). Check if the `memory-bank/` folder and essential files were created at the project root after following the initialization plan provided by Roo Code in Architect mode.
2. Initial Mode Switch: After VS Code restart, switch to "Ask" or "Architect" mode *first* to trigger Memory Bank loading.
3. Use "Update Memory Bank" (UMB) Command: Use "update memory bank" or **"UMB" as a standalone prompt** at session end to explicitly trigger the comprehensive Memory Bank update and prepare for the next session.
4. Check File Paths: Verify `memory-bank/` folder is at project root; incorrect paths prevent Memory Bank access.


.clinerules Rules Not Applied


Solution:
1. File Location: Ensure `.clinerules` files (`.clinerules`, `.clinerules-code`, etc.) are at project root, alongside `memory-bank/` folder.
2. Syntax Check: Verify `.clinerules` file syntax; incorrect syntax may cause rules to be ignored.
3. Mode Relevance: Note that `.clinerules-code`, `.clinerules-architect`, `.clinerules-ask` are mode-specific.
4. Restart Roo Code (Rare):  Restart Roo Code in VS Code after major `.clinerules` changes to reload rules.


Memory Bank Files Not Updating/Saving


Solution:
1. File Permissions: Check write permissions for `memory-bank/` folder and files.
2. VS Code Errors: Check VS Code console for file saving errors.
3. Conflicting Extensions: Temporarily disable extensions that might interfere with saving.
4. Disk Space: Ensure sufficient free disk space is available.


If issues persist, consult the Roo Code documentation or community support channels for further assistance.


Revised Guidance on "Update Memory Bank" (UMB) Command:


Although not strictly *required* after every break, using the **"Update Memory Bank" (UMB) command** (typing "update memory bank" or "UMB" as a standalone prompt in chat) is **highly recommended and should be considered a best practice** for robust session management and ensuring long-term project context preservation.  **Triggering UMB as a standalone prompt ensures a comprehensive update of all Memory Bank files, guaranteeing accurate and persistent project knowledge.**


To visualize this session management process, refer to the workflow diagram below:


Session Management Workflow (`update memory bank` Command)


[//]: # (TODO: Replace ASCII diagram below with a visual flowchart image)
[//]: # (Visual flowchart image should illustrate the Session Management Workflow with `update memory bank` command. A flowchart would be more user-friendly than the current ASCII diagram.)


1. Start: Working on Project (Any Mode)
2. Step 1: User makes changes to Memory Bank files (`productContext.md`, `activeContext.md`, `progress.md`, etc.)
3. Step 2: Session End or Break?
 Yes: User initiates `update memory bank` command in chat
 No: Continue Working (Loop back to Step 1)
4. Step 3: Roo Code saves current state of Memory Bank files
5. Step 4: Memory Bank is prepared for next session
6. End: Session Managed & Memory Bank Updated


Think of it as:
* `[MEMORY BANK: ACTIVE]` Prefix:  Ensures Roo uses *documented, reliable* project context in Code mode (important for memory resets).
* `update memory bank` Command: "Save project knowledge" command. Use it to:
  * Update Memory Bank at session end/breaks.
  * Prepare for VS Code closure/workspace switch.
  * Create project history checkpoints.
</file>

<file path="init.lua">
--[[

=====================================================================
==================== READ THIS BEFORE CONTINUING ====================
=====================================================================
========                                    .-----.          ========
========         .----------------------.   | === |          ========
========         |.-""""""""""""""""""-.|   |-----|          ========
========         ||                    ||   | === |          ========
========         ||   KICKSTART.NVIM   ||   |-----|          ========
========         ||                    ||   | === |          ========
========         ||                    ||   |-----|          ========
========         ||:Tutor              ||   |:::::|          ========
========         |'-..................-'|   |____o|          ========
========         `"")----------------(""`   ___________      ========
========        /::::::::::|  |::::::::::\  \ no mouse \     ========
========       /:::========|  |==hjkl==:::\  \ required \    ========
========      '""""""""""""'  '""""""""""""'  '""""""""""'   ========
========                                                     ========
=====================================================================
=====================================================================

What is Kickstart?

  Kickstart.nvim is *not* a distribution.

  Kickstart.nvim is a starting point for your own configuration.
    The goal is that you can read every line of code, top-to-bottom, understand
    what your configuration is doing, and modify it to suit your needs.

    Once you've done that, you can start exploring, configuring and tinkering to
    make Neovim your own! That might mean leaving Kickstart just the way it is for a while
    or immediately breaking it into modular pieces. It's up to you!

    If you don't know anything about Lua, I recommend taking some time to read through
    a guide. One possible example which will only take 10-15 minutes:
      - https://learnxinyminutes.com/docs/lua/

    After understanding a bit more about Lua, you can use `:help lua-guide` as a
    reference for how Neovim integrates Lua.
    - :help lua-guide
    - (or HTML version): https://neovim.io/doc/user/lua-guide.html

Kickstart Guide:

  TODO: The very first thing you should do is to run the command `:Tutor` in Neovim.

    If you don't know what this means, type the following:
      - <escape key>
      - :
      - Tutor
      - <enter key>

    (If you already know the Neovim basics, you can skip this step.)

  Once you've completed that, you can continue working through **AND READING** the rest
  of the kickstart init.lua.

  Next, run AND READ `:help`.
    This will open up a help window with some basic information
    about reading, navigating and searching the builtin help documentation.

    This should be the first place you go to look when you're stuck or confused
    with something. It's one of my favorite Neovim features.

    MOST IMPORTANTLY, we provide a keymap "<space>sh" to [s]earch the [h]elp documentation,
    which is very useful when you're not exactly sure of what you're looking for.

  I have left several `:help X` comments throughout the init.lua
    These are hints about where to find more information about the relevant settings,
    plugins or Neovim features used in Kickstart.

   NOTE: Look for lines like this

    Throughout the file. These are for you, the reader, to help you understand what is happening.
    Feel free to delete them once you know what you're doing, but they should serve as a guide
    for when you are first encountering a few different constructs in your Neovim config.

If you experience any errors while trying to install kickstart, run `:checkhealth` for more info.

I hope you enjoy your Neovim journey,
- TJ

P.S. You can delete this when you're done too. It's your config now! :)
--]]

-- Set <space> as the leader key
-- See `:help mapleader`
--  NOTE: Must happen before plugins are loaded (otherwise wrong leader will be used)
vim.g.mapleader = ' '
vim.g.maplocalleader = ' '

-- Set to true if you have a Nerd Font installed and selected in the terminal
vim.g.have_nerd_font = false

-- [[ Setting options ]]
-- See `:help vim.opt`
-- NOTE: You can change these options as you wish!
--  For more options, you can see `:help option-list`

-- Make line numbers default
vim.opt.number = true
-- You can also add relative line numbers, to help with jumping.
--  Experiment for yourself to see if you like it!
-- vim.opt.relativenumber = true

-- Enable mouse mode, can be useful for resizing splits for example!
vim.opt.mouse = 'a'

-- Don't show the mode, since it's already in the status line
vim.opt.showmode = false

-- Sync clipboard between OS and Neovim.
--  Schedule the setting after `UiEnter` because it can increase startup-time.
--  Remove this option if you want your OS clipboard to remain independent.
--  See `:help 'clipboard'`
vim.schedule(function()
  vim.opt.clipboard = 'unnamedplus'
end)

-- Enable break indent
vim.opt.breakindent = true

-- Save undo history
vim.opt.undofile = true

-- Case-insensitive searching UNLESS \C or one or more capital letters in the search term
vim.opt.ignorecase = true
vim.opt.smartcase = true

-- Keep signcolumn on by default
vim.opt.signcolumn = 'yes'

-- Decrease update time
vim.opt.updatetime = 250

-- Decrease mapped sequence wait time
vim.opt.timeoutlen = 300

-- Configure how new splits should be opened
vim.opt.splitright = true
vim.opt.splitbelow = true

-- Sets how neovim will display certain whitespace characters in the editor.
--  See `:help 'list'`
--  and `:help 'listchars'`
vim.opt.list = true
vim.opt.listchars = { tab = '» ', trail = '·', nbsp = '␣' }

-- Preview substitutions live, as you type!
vim.opt.inccommand = 'split'

-- Show which line your cursor is on
vim.opt.cursorline = true

-- Minimal number of screen lines to keep above and below the cursor.
vim.opt.scrolloff = 10

-- [[ Basic Keymaps ]]
--  See `:help vim.keymap.set()`

-- Clear highlights on search when pressing <Esc> in normal mode
--  See `:help hlsearch`
vim.keymap.set('n', '<Esc>', '<cmd>nohlsearch<CR>')

-- Diagnostic keymaps
vim.keymap.set('n', '<leader>q', vim.diagnostic.setloclist, { desc = 'Open diagnostic [Q]uickfix list' })

-- Exit terminal mode in the builtin terminal with a shortcut that is a bit easier
-- for people to discover. Otherwise, you normally need to press <C-\><C-n>, which
-- is not what someone will guess without a bit more experience.
--
-- NOTE: This won't work in all terminal emulators/tmux/etc. Try your own mapping
-- or just use <C-\><C-n> to exit terminal mode
vim.keymap.set('t', '<Esc><Esc>', '<C-\\><C-n>', { desc = 'Exit terminal mode' })

-- TIP: Disable arrow keys in normal mode
vim.keymap.set('n', '<left>', '<cmd>echo "Use h to move!!"<CR>')
vim.keymap.set('n', '<right>', '<cmd>echo "Use l to move!!"<CR>')
vim.keymap.set('n', '<up>', '<cmd>echo "Use k to move!!"<CR>')
vim.keymap.set('n', '<down>', '<cmd>echo "Use j to move!!"<CR>')

-- Keybinds to make split navigation easier.
--  Use CTRL+<hjkl> to switch between windows
--
--  See `:help wincmd` for a list of all window commands
vim.keymap.set('n', '<C-h>', '<C-w><C-h>', { desc = 'Move focus to the left window' })
vim.keymap.set('n', '<C-l>', '<C-w><C-l>', { desc = 'Move focus to the right window' })
vim.keymap.set('n', '<C-j>', '<C-w><C-j>', { desc = 'Move focus to the lower window' })
vim.keymap.set('n', '<C-k>', '<C-w><C-k>', { desc = 'Move focus to the upper window' })

-- [[ Basic Autocommands ]]
--  See `:help lua-guide-autocommands`

-- Highlight when yanking (copying) text
--  Try it with `yap` in normal mode
--  See `:help vim.highlight.on_yank()`
vim.api.nvim_create_autocmd('TextYankPost', {
  desc = 'Highlight when yanking (copying) text',
  group = vim.api.nvim_create_augroup('kickstart-highlight-yank', { clear = true }),
  callback = function()
    vim.highlight.on_yank()
  end,
})

-- [[ Install `lazy.nvim` plugin manager ]]
--    See `:help lazy.nvim.txt` or https://github.com/folke/lazy.nvim for more info
local lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'
if not (vim.uv or vim.loop).fs_stat(lazypath) then
  local lazyrepo = 'https://github.com/folke/lazy.nvim.git'
  local out = vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }
  if vim.v.shell_error ~= 0 then
    error('Error cloning lazy.nvim:\n' .. out)
  end
end ---@diagnostic disable-next-line: undefined-field
vim.opt.rtp:prepend(lazypath)

-- [[ Configure and install plugins ]]
--
--  To check the current status of your plugins, run
--    :Lazy
--
--  You can press `?` in this menu for help. Use `:q` to close the window
--
--  To update plugins you can run
--    :Lazy update
--
-- NOTE: Here is where you install your plugins.
require('lazy').setup({
  -- NOTE: Plugins can be added with a link (or for a github repo: 'owner/repo' link).
  'tpope/vim-sleuth', -- Detect tabstop and shiftwidth automatically

  -- NOTE: Plugins can also be added by using a table,
  -- with the first argument being the link and the following
  -- keys can be used to configure plugin behavior/loading/etc.
  --
  -- Use `opts = {}` to automatically pass options to a plugin's `setup()` function, forcing the plugin to be loaded.
  --

  -- Alternatively, use `config = function() ... end` for full control over the configuration.
  -- If you prefer to call `setup` explicitly, use:
  --    {
  --        'lewis6991/gitsigns.nvim',
  --        config = function()
  --            require('gitsigns').setup({
  --                -- Your gitsigns configuration here
  --            })
  --        end,
  --    }
  --
  -- Here is a more advanced example where we pass configuration
  -- options to `gitsigns.nvim`.
  --
  -- See `:help gitsigns` to understand what the configuration keys do
  { -- Adds git related signs to the gutter, as well as utilities for managing changes
    'lewis6991/gitsigns.nvim',
    opts = {
      signs = {
        add = { text = '+' },
        change = { text = '~' },
        delete = { text = '_' },
        topdelete = { text = '‾' },
        changedelete = { text = '~' },
      },
    },
  },

  -- NOTE: Plugins can also be configured to run Lua code when they are loaded.
  --
  -- This is often very useful to both group configuration, as well as handle
  -- lazy loading plugins that don't need to be loaded immediately at startup.
  --
  -- For example, in the following configuration, we use:
  --  event = 'VimEnter'
  --
  -- which loads which-key before all the UI elements are loaded. Events can be
  -- normal autocommands events (`:help autocmd-events`).
  --
  -- Then, because we use the `opts` key (recommended), the configuration runs
  -- after the plugin has been loaded as `require(MODULE).setup(opts)`.

  { -- Useful plugin to show you pending keybinds.
    'folke/which-key.nvim',
    event = 'VimEnter', -- Sets the loading event to 'VimEnter'
    opts = {
      plugins = {
        marks = true,
        registers = true,
        spelling = { enabled = false }
      },
      show_help = true
    },
  },

  -- NOTE: Plugins can specify dependencies.
  --
  -- The dependencies are proper plugin specifications as well - anything
  -- you do for a plugin at the top level, you can do for a dependency.
  --
  -- Use the `dependencies` key to specify the dependencies of a particular plugin

  { -- Fuzzy Finder (files, lsp, etc)
    'nvim-telescope/telescope.nvim',
    event = 'VimEnter',
    branch = '0.1.x',
    dependencies = {
      'nvim-lua/plenary.nvim',
      { -- If encountering errors, see telescope-fzf-native README for installation instructions
        'nvim-telescope/telescope-fzf-native.nvim',

        -- `build` is used to run some command when the plugin is installed/updated.
        -- This is only run then, not every time Neovim starts up.
        build = 'make',

        -- `cond` is a condition used to determine whether this plugin should be
        -- installed and loaded.
        cond = function()
          return vim.fn.executable 'make' == 1
        end,
      },
      { 'nvim-telescope/telescope-ui-select.nvim' },

      -- Useful for getting pretty icons, but requires a Nerd Font.
      { 'nvim-tree/nvim-web-devicons', enabled = vim.g.have_nerd_font },
    },
    config = function()
      -- Telescope is a fuzzy finder that comes with a lot of different things that
      -- it can fuzzy find! It's more than just a "file finder", it can search
      -- many different aspects of Neovim, your workspace, LSP, and more!
      --
      -- The easiest way to use Telescope, is to start by doing something like:
      --  :Telescope help_tags
      --
      -- After running this command, a window will open up and you're able to
      -- type in the prompt window. You'll see a list of `help_tags` options and
      -- a corresponding preview of the help.
      --
      -- Two important keymaps to use while in Telescope are:
      --  - Insert mode: <c-/>
      --  - Normal mode: ?
      --
      -- This opens a window that shows you all of the keymaps for the current
      -- Telescope picker. This is really useful to discover what Telescope can
      -- do as well as how to actually do it!

      -- [[ Configure Telescope ]]
      -- See `:help telescope` and `:help telescope.setup()`
      require('telescope').setup {
        -- You can put your default mappings / updates / etc. in here
        --  All the info you're looking for is in `:help telescope.setup()`
        --
        -- defaults = {
        --   mappings = {
        --     i = { ['<c-enter>'] = 'to_fuzzy_refine' },
        --   },
        -- },
        -- pickers = {}
        extensions = {
          ['ui-select'] = {
            require('telescope.themes').get_dropdown(),
          },
        },
      }

      -- Enable Telescope extensions if they are installed
      pcall(require('telescope').load_extension, 'fzf')
      pcall(require('telescope').load_extension, 'ui-select')

      -- See `:help telescope.builtin`
      local builtin = require 'telescope.builtin'
      vim.keymap.set('n', '<leader>sh', builtin.help_tags, { desc = '[S]earch [H]elp' })
      vim.keymap.set('n', '<leader>sk', builtin.keymaps, { desc = '[S]earch [K]eymaps' })
      vim.keymap.set('n', '<leader>sf', builtin.find_files, { desc = '[S]earch [F]iles' })
      vim.keymap.set('n', '<leader>ss', builtin.builtin, { desc = '[S]earch [S]elect Telescope' })
      vim.keymap.set('n', '<leader>sw', builtin.grep_string, { desc = '[S]earch current [W]ord' })
      vim.keymap.set('n', '<leader>sg', builtin.live_grep, { desc = '[S]earch by [G]rep' })
      vim.keymap.set('n', '<leader>sd', builtin.diagnostics, { desc = '[S]earch [D]iagnostics' })
      vim.keymap.set('n', '<leader>sr', builtin.resume, { desc = '[S]earch [R]esume' })
      vim.keymap.set('n', '<leader>s.', builtin.oldfiles, { desc = '[S]earch Recent Files ("." for repeat)' })
      vim.keymap.set('n', '<leader><leader>', builtin.buffers, { desc = '[ ] Find existing buffers' })

      -- Slightly advanced example of overriding default behavior and theme
      vim.keymap.set('n', '<leader>/', function()
        -- You can pass additional configuration to Telescope to change the theme, layout, etc.
        builtin.current_buffer_fuzzy_find(require('telescope.themes').get_dropdown {
          winblend = 10,
          previewer = false,
        })
      end, { desc = '[/] Fuzzily search in current buffer' })

      -- It's also possible to pass additional configuration options.
      --  See `:help telescope.builtin.live_grep()` for information about particular keys
      vim.keymap.set('n', '<leader>s/', function()
        builtin.live_grep {
          grep_open_files = true,
          prompt_title = 'Live Grep in Open Files',
        }
      end, { desc = '[S]earch [/] in Open Files' })

      -- Shortcut for searching your Neovim configuration files
      vim.keymap.set('n', '<leader>sn', function()
        builtin.find_files { cwd = vim.fn.stdpath 'config' }
      end, { desc = '[S]earch [N]eovim files' })
    end,
  },

  -- LSP Plugins
  {
    -- `lazydev` configures Lua LSP for your Neovim config, runtime and plugins
    -- used for completion, annotations and signatures of Neovim apis
    'folke/lazydev.nvim',
    ft = 'lua',
    opts = {
      library = {
        -- Load luvit types when the `vim.uv` word is found
        { path = '${3rd}/luv/library', words = { 'vim%.uv' } },
      },
    },
  },
  {
    -- Main LSP Configuration
    'neovim/nvim-lspconfig',
    dependencies = {
      -- Automatically install LSPs and related tools to stdpath for Neovim
      -- Mason must be loaded before its dependents so we need to set it up here.
      -- NOTE: `opts = {}` is the same as calling `require('mason').setup({})`
      { 'williamboman/mason.nvim', opts = {} },
      'williamboman/mason-lspconfig.nvim',
      'WhoIsSethDaniel/mason-tool-installer.nvim',

      -- Useful status updates for LSP.
      { 'j-hui/fidget.nvim', opts = {} },

      -- Allows extra capabilities provided by nvim-cmp
      'hrsh7th/cmp-nvim-lsp',
    },
    config = function()
      -- Brief aside: **What is LSP?**
      --
      -- LSP is an initialism you've probably heard, but might not understand what it is.
      --
      -- LSP stands for Language Server Protocol. It's a protocol that helps editors
      -- and language tooling communicate in a standardized fashion.
      --
      -- In general, you have a "server" which is some tool built to understand a particular
      -- language (such as `gopls`, `lua_ls`, `rust_analyzer`, etc.). These Language Servers
      -- (sometimes called LSP servers, but that's kind of like ATM Machine) are standalone
      -- processes that communicate with some "client" - in this case, Neovim!
      --
      -- LSP provides Neovim with features like:
      --  - Go to definition
      --  - Find references
      --  - Autocompletion
      --  - Symbol Search
      --  - and more!
      --
      -- Thus, Language Servers are external tools that must be installed separately from
      -- Neovim. This is where `mason` and related plugins come into play.
      --
      -- If you're wondering about lsp vs treesitter, you can check out the wonderfully
      -- and elegantly composed help section, `:help lsp-vs-treesitter`

      --  This function gets run when an LSP attaches to a particular buffer.
      --    That is to say, every time a new file is opened that is associated with
      --    an lsp (for example, opening `main.rs` is associated with `rust_analyzer`) this
      --    function will be executed to configure the current buffer
      vim.api.nvim_create_autocmd('LspAttach', {
        group = vim.api.nvim_create_augroup('kickstart-lsp-attach', { clear = true }),
        callback = function(event)
          -- NOTE: Remember that Lua is a real programming language, and as such it is possible
          -- to define small helper and utility functions so you don't have to repeat yourself.
          --
          -- In this case, we create a function that lets us more easily define mappings specific
          -- for LSP related items. It sets the mode, buffer and description for us each time.
          local map = function(keys, func, desc, mode)
            mode = mode or 'n'
            vim.keymap.set(mode, keys, func, { buffer = event.buf, desc = 'LSP: ' .. desc })
          end

          -- Jump to the definition of the word under your cursor.
          --  This is where a variable was first declared, or where a function is defined, etc.
          --  To jump back, press <C-t>.
          map('gd', require('telescope.builtin').lsp_definitions, '[G]oto [D]efinition')

          -- Find references for the word under your cursor.
          map('gr', require('telescope.builtin').lsp_references, '[G]oto [R]eferences')

          -- Jump to the implementation of the word under your cursor.
          --  Useful when your language has ways of declaring types without an actual implementation.
          map('gI', require('telescope.builtin').lsp_implementations, '[G]oto [I]mplementation')

          -- Jump to the type of the word under your cursor.
          --  Useful when you're not sure what type a variable is and you want to see
          --  the definition of its *type*, not where it was *defined*.
          map('<leader>D', require('telescope.builtin').lsp_type_definitions, 'Type [D]efinition')

          -- Fuzzy find all the symbols in your current document.
          --  Symbols are things like variables, functions, types, etc.
          map('<leader>ds', require('telescope.builtin').lsp_document_symbols, '[D]ocument [S]ymbols')

          -- Fuzzy find all the symbols in your current workspace.
          --  Similar to document symbols, except searches over your entire project.
          map('<leader>ws', require('telescope.builtin').lsp_dynamic_workspace_symbols, '[W]orkspace [S]ymbols')

          -- Rename the variable under your cursor.
          --  Most Language Servers support renaming across files, etc.
          map('<leader>rn', vim.lsp.buf.rename, '[R]e[n]ame')

          -- Execute a code action, usually your cursor needs to be on top of an error
          -- or a suggestion from your LSP for this to activate.
          map('<leader>ca', vim.lsp.buf.code_action, '[C]ode [A]ction', { 'n', 'x' })

          -- WARN: This is not Goto Definition, this is Goto Declaration.
          --  For example, in C this would take you to the header.
          map('gD', vim.lsp.buf.declaration, '[G]oto [D]eclaration')

          -- This function resolves a difference between neovim nightly (version 0.11) and stable (version 0.10)
          ---@param client vim.lsp.Client
          ---@param method vim.lsp.protocol.Method
          ---@param bufnr? integer some lsp support methods only in specific files
          ---@return boolean
          local function client_supports_method(client, method, bufnr)
            if vim.fn.has 'nvim-0.11' == 1 then
              return client:supports_method(method, bufnr)
            else
              return client.supports_method(method, { bufnr = bufnr })
            end
          end

          -- The following two autocommands are used to highlight references of the
          -- word under your cursor when your cursor rests there for a little while.
          --    See `:help CursorHold` for information about when this is executed
          --
          -- When you move your cursor, the highlights will be cleared (the second autocommand).
          local client = vim.lsp.get_client_by_id(event.data.client_id)
          if client and client_supports_method(client, vim.lsp.protocol.Methods.textDocument_documentHighlight, event.buf) then
            local highlight_augroup = vim.api.nvim_create_augroup('kickstart-lsp-highlight', { clear = false })
            vim.api.nvim_create_autocmd({ 'CursorHold', 'CursorHoldI' }, {
              buffer = event.buf,
              group = highlight_augroup,
              callback = vim.lsp.buf.document_highlight,
            })

            vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {
              buffer = event.buf,
              group = highlight_augroup,
              callback = vim.lsp.buf.clear_references,
            })

            vim.api.nvim_create_autocmd('LspDetach', {
              group = vim.api.nvim_create_augroup('kickstart-lsp-detach', { clear = true }),
              callback = function(event2)
                vim.lsp.buf.clear_references()
                vim.api.nvim_clear_autocmds { group = 'kickstart-lsp-highlight', buffer = event2.buf }
              end,
            })
          end

          -- The following code creates a keymap to toggle inlay hints in your
          -- code, if the language server you are using supports them
          --
          -- This may be unwanted, since they displace some of your code
          if client and client_supports_method(client, vim.lsp.protocol.Methods.textDocument_inlayHint, event.buf) then
            map('<leader>th', function()
              vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled { bufnr = event.buf })
            end, '[T]oggle Inlay [H]ints')
          end
        end,
      })

      -- Diagnostic Config
      -- See :help vim.diagnostic.Opts
      vim.diagnostic.config {
        severity_sort = true,
        float = { border = 'rounded', source = 'if_many' },
        underline = { severity = vim.diagnostic.severity.ERROR },
        signs = vim.g.have_nerd_font and {
          text = {
            [vim.diagnostic.severity.ERROR] = '󰅚 ',
            [vim.diagnostic.severity.WARN] = '󰀪 ',
            [vim.diagnostic.severity.INFO] = '󰋽 ',
            [vim.diagnostic.severity.HINT] = '󰌶 ',
          },
        } or {},
        virtual_text = {
          source = 'if_many',
          spacing = 2,
          format = function(diagnostic)
            local diagnostic_message = {
              [vim.diagnostic.severity.ERROR] = diagnostic.message,
              [vim.diagnostic.severity.WARN] = diagnostic.message,
              [vim.diagnostic.severity.INFO] = diagnostic.message,
              [vim.diagnostic.severity.HINT] = diagnostic.message,
            }
            return diagnostic_message[diagnostic.severity]
          end,
        },
      }

      -- LSP servers and clients are able to communicate to each other what features they support.
      --  By default, Neovim doesn't support everything that is in the LSP specification.
      --  When you add nvim-cmp, luasnip, etc. Neovim now has *more* capabilities.
      --  So, we create new capabilities with nvim cmp, and then broadcast that to the servers.
      local capabilities = vim.lsp.protocol.make_client_capabilities()
      capabilities = vim.tbl_deep_extend('force', capabilities, require('cmp_nvim_lsp').default_capabilities())

      -- Enable the following language servers
      --  Feel free to add/remove any LSPs that you want here. They will automatically be installed.
      --
      --  Add any additional override configuration in the following tables. Available keys are:
      --  - cmd (table): Override the default command used to start the server
      --  - filetypes (table): Override the default list of associated filetypes for the server
      --  - capabilities (table): Override fields in capabilities. Can be used to disable certain LSP features.
      --  - settings (table): Override the default settings passed when initializing the server.
      --        For example, to see the options for `lua_ls`, you could go to: https://luals.github.io/wiki/settings/
      local servers = {
        -- clangd = {},
        -- gopls = {},
        -- pyright = {},
        -- rust_analyzer = {},
        -- ... etc. See `:help lspconfig-all` for a list of all the pre-configured LSPs
        --
        -- Some languages (like typescript) have entire language plugins that can be useful:
        --    https://github.com/pmizio/typescript-tools.nvim
        --
        -- But for many setups, the LSP (`ts_ls`) will work just fine
        -- ts_ls = {},
        --

        lua_ls = {
          -- cmd = { ... },
          -- filetypes = { ... },
          -- capabilities = {},
          settings = {
            Lua = {
              completion = {
                callSnippet = 'Replace',
              },
              -- You can toggle below to ignore Lua_LS's noisy `missing-fields` warnings
              -- diagnostics = { disable = { 'missing-fields' } },
            },
          },
        },
      }

      -- Ensure the servers and tools above are installed
      --
      -- To check the current status of installed tools and/or manually install
      -- other tools, you can run
      --    :Mason
      --
      -- You can press `g?` for help in this menu.
      --
      -- `mason` had to be setup earlier: to configure its options see the
      -- `dependencies` table for `nvim-lspconfig` above.
      --
      -- You can add other tools here that you want Mason to install
      -- for you, so that they are available from within Neovim.
      local ensure_installed = vim.tbl_keys(servers or {})
      vim.list_extend(ensure_installed, {
        'stylua', -- Used to format Lua code
      })
      require('mason-tool-installer').setup { ensure_installed = ensure_installed }

      require('mason-lspconfig').setup {
        ensure_installed = {}, -- explicitly set to an empty table (Kickstart populates installs via mason-tool-installer)
        automatic_installation = false,
        handlers = {
          function(server_name)
            local server = servers[server_name] or {}
            -- This handles overriding only values explicitly passed
            -- by the server configuration above. Useful when disabling
            -- certain features of an LSP (for example, turning off formatting for ts_ls)
            server.capabilities = vim.tbl_deep_extend('force', {}, capabilities, server.capabilities or {})
            require('lspconfig')[server_name].setup(server)
          end,
        },
      }
    end,
  },

  { -- Autoformat
    'stevearc/conform.nvim',
    event = { 'BufWritePre' },
    cmd = { 'ConformInfo' },
    keys = {
      {
        '<leader>f',
        function()
          require('conform').format { async = true, lsp_format = 'fallback' }
        end,
        mode = '',
        desc = '[F]ormat buffer',
      },
    },
    opts = {
      notify_on_error = false,
      format_on_save = function(bufnr)
        -- Disable "format_on_save lsp_fallback" for languages that don't
        -- have a well standardized coding style. You can add additional
        -- languages here or re-enable it for the disabled ones.
        local disable_filetypes = { c = true, cpp = true }
        local lsp_format_opt
        if disable_filetypes[vim.bo[bufnr].filetype] then
          lsp_format_opt = 'never'
        else
          lsp_format_opt = 'fallback'
        end
        return {
          timeout_ms = 500,
          lsp_format = lsp_format_opt,
        }
      end,
      formatters_by_ft = {
        lua = { 'stylua' },
        -- Conform can also run multiple formatters sequentially
        -- python = { "isort", "black" },
        --
        -- You can use 'stop_after_first' to run the first available formatter from the list
        -- javascript = { "prettierd", "prettier", stop_after_first = true },
      },
    },
  },

  { -- Autocompletion
    'hrsh7th/nvim-cmp',
    event = 'InsertEnter',
    dependencies = {
      -- Snippet Engine & its associated nvim-cmp source
      {
        'L3MON4D3/LuaSnip',
        build = (function()
          -- Build Step is needed for regex support in snippets.
          -- This step is not supported in many windows environments.
          -- Remove the below condition to re-enable on windows.
          if vim.fn.has 'win32' == 1 or vim.fn.executable 'make' == 0 then
            return
          end
          return 'make install_jsregexp'
        end)(),
        dependencies = {
          -- `friendly-snippets` contains a variety of premade snippets.
          --    See the README about individual language/framework/plugin snippets:
          --    https://github.com/rafamadriz/friendly-snippets
          -- {
          --   'rafamadriz/friendly-snippets',
          --   config = function()
          --     require('luasnip.loaders.from_vscode').lazy_load()
          --   end,
          -- },
        },
      },
      'saadparwaiz1/cmp_luasnip',

      -- Adds other completion capabilities.
      --  nvim-cmp does not ship with all sources by default. They are split
      --  into multiple repos for maintenance purposes.
      'hrsh7th/cmp-nvim-lsp',
      'hrsh7th/cmp-path',
      'hrsh7th/cmp-nvim-lsp-signature-help',
    },
    config = function()
      -- See `:help cmp`
      local cmp = require 'cmp'
      local luasnip = require 'luasnip'
      luasnip.config.setup {}

      cmp.setup {
        snippet = {
          expand = function(args)
            luasnip.lsp_expand(args.body)
          end,
        },
        completion = { completeopt = 'menu,menuone,noinsert' },

        -- For an understanding of why these mappings were
        -- chosen, you will need to read `:help ins-completion`
        --
        -- No, but seriously. Please read `:help ins-completion`, it is really good!
        mapping = cmp.mapping.preset.insert {
          -- Select the [n]ext item
          ['<C-n>'] = cmp.mapping.select_next_item(),
          -- Select the [p]revious item
          ['<C-p>'] = cmp.mapping.select_prev_item(),

          -- Scroll the documentation window [b]ack / [f]orward
          ['<C-b>'] = cmp.mapping.scroll_docs(-4),
          ['<C-f>'] = cmp.mapping.scroll_docs(4),

          -- Accept ([y]es) the completion.
          --  This will auto-import if your LSP supports it.
          --  This will expand snippets if the LSP sent a snippet.
          ['<C-y>'] = cmp.mapping.confirm { select = true },

          -- If you prefer more traditional completion keymaps,
          -- you can uncomment the following lines
          --['<CR>'] = cmp.mapping.confirm { select = true },
          --['<Tab>'] = cmp.mapping.select_next_item(),
          --['<S-Tab>'] = cmp.mapping.select_prev_item(),

          -- Manually trigger a completion from nvim-cmp.
          --  Generally you don't need this, because nvim-cmp will display
          --  completions whenever it has completion options available.
          ['<C-Space>'] = cmp.mapping.complete {},

          -- Think of <c-l> as moving to the right of your snippet expansion.
          --  So if you have a snippet that's like:
          --  function $name($args)
          --    $body
          --  end
          --
          -- <c-l> will move you to the right of each of the expansion locations.
          -- <c-h> is similar, except moving you backwards.
          ['<C-l>'] = cmp.mapping(function()
            if luasnip.expand_or_locally_jumpable() then
              luasnip.expand_or_jump()
            end
          end, { 'i', 's' }),
          ['<C-h>'] = cmp.mapping(function()
            if luasnip.locally_jumpable(-1) then
              luasnip.jump(-1)
            end
          end, { 'i', 's' }),

          -- For more advanced Luasnip keymaps (e.g. selecting choice nodes, expansion) see:
          --    https://github.com/L3MON4D3/LuaSnip?tab=readme-ov-file#keymaps
        },
        sources = {
          {
            name = 'lazydev',
            -- set group index to 0 to skip loading LuaLS completions as lazydev recommends it
            group_index = 0,
          },
          { name = 'nvim_lsp' },
          { name = 'luasnip' },
          { name = 'path' },
          { name = 'nvim_lsp_signature_help' },
        },
      }
    end,
  },

  { -- You can easily change to a different colorscheme.
    -- Change the name of the colorscheme plugin below, and then
    -- change the command in the config to whatever the name of that colorscheme is.
    --
    -- If you want to see what colorschemes are already installed, you can use `:Telescope colorscheme`.
    'folke/tokyonight.nvim',
    priority = 1000, -- Make sure to load this before all the other start plugins.
    config = function()
      ---@diagnostic disable-next-line: missing-fields
      require('tokyonight').setup {
        styles = {
          comments = { italic = false }, -- Disable italics in comments
        },
      }

      -- Load the colorscheme here.
      -- Like many other themes, this one has different styles, and you could load
      -- any other, such as 'tokyonight-storm', 'tokyonight-moon', or 'tokyonight-day'.
      vim.cmd.colorscheme 'tokyonight-night'
    end,
  },

  -- Highlight todo, notes, etc in comments
  { 'folke/todo-comments.nvim', event = 'VimEnter', dependencies = { 'nvim-lua/plenary.nvim' }, opts = { signs = false } },

  { -- Collection of various small independent plugins/modules
    'echasnovski/mini.nvim',
    config = function()
      -- Better Around/Inside textobjects
      --
      -- Examples:
      --  - va)  - [V]isually select [A]round [)]paren
      --  - yinq - [Y]ank [I]nside [N]ext [Q]uote
      --  - ci'  - [C]hange [I]nside [']quote
      require('mini.ai').setup { n_lines = 500 }

      -- Add/delete/replace surroundings (brackets, quotes, etc.)
      --
      -- - saiw) - [S]urround [A]dd [I]nner [W]ord [)]Paren
      -- - sd'   - [S]urround [D]elete [']quotes
      -- - sr)'  - [S]urround [R]eplace [)] [']
      require('mini.surround').setup()

      -- Simple and easy statusline.
      --  You could remove this setup call if you don't like it,
      --  and try some other statusline plugin
      local statusline = require 'mini.statusline'
      -- set use_icons to true if you have a Nerd Font
      statusline.setup { use_icons = vim.g.have_nerd_font }

      -- You can configure sections in the statusline by overriding their
      -- default behavior. For example, here we set the section for
      -- cursor location to LINE:COLUMN
      ---@diagnostic disable-next-line: duplicate-set-field
      statusline.section_location = function()
        return '%2l:%-2v'
      end

      -- ... and there is more!
      --  Check out: https://github.com/echasnovski/mini.nvim
    end,
  },
  { -- Highlight, edit, and navigate code
    'nvim-treesitter/nvim-treesitter',
    build = ':TSUpdate',
    main = 'nvim-treesitter.configs', -- Sets main module to use for opts
    -- [[ Configure Treesitter ]] See `:help nvim-treesitter`
    opts = {
      ensure_installed = { 'bash', 'c', 'diff', 'html', 'lua', 'luadoc', 'markdown', 'markdown_inline', 'query', 'vim', 'vimdoc' },
      -- Autoinstall languages that are not installed
      auto_install = true,
      highlight = {
        enable = true,
        -- Some languages depend on vim's regex highlighting system (such as Ruby) for indent rules.
        --  If you are experiencing weird indenting issues, add the language to
        --  the list of additional_vim_regex_highlighting and disabled languages for indent.
        additional_vim_regex_highlighting = { 'ruby' },
      },
      indent = { enable = true, disable = { 'ruby' } },
    },
    -- There are additional nvim-treesitter modules that you can use to interact
    -- with nvim-treesitter. You should go explore a few and see what interests you:
    --
    --    - Incremental selection: Included, see `:help nvim-treesitter-incremental-selection-mod`
    --    - Show your current context: https://github.com/nvim-treesitter/nvim-treesitter-context
    --    - Treesitter + textobjects: https://github.com/nvim-treesitter/nvim-treesitter-textobjects
  },

  -- The following comments only work if you have downloaded the kickstart repo, not just copy pasted the
  -- init.lua. If you want these files, they are in the repository, so you can just download them and
  -- place them in the correct locations.

  -- NOTE: Next step on your Neovim journey: Add/Configure additional plugins for Kickstart
  --
  --  Here are some example plugins that I've included in the Kickstart repository.
  --  Uncomment any of the lines below to enable them (you will need to restart nvim).
  --
    require 'kickstart.plugins.debug',
  require 'kickstart.plugins.indent_line',
  require 'kickstart.plugins.lint',
  require 'kickstart.plugins.autopairs',
  require 'kickstart.plugins.neo-tree',
  require 'kickstart.plugins.gitsigns', -- adds gitsigns recommend keymaps

  -- NOTE: The import below can automatically add your own plugins, configuration, etc from `lua/custom/plugins/*.lua`
  --    This is the easiest way to modularize your config.
  --
  --  Uncomment the following line and add your plugins to `lua/custom/plugins/*.lua` to get going.
  { import = 'custom.plugins' },
  --
  -- For additional information with loading, sourcing and examples see `:help lazy.nvim-🔌-plugin-spec`
  -- Or use telescope!
  -- In normal mode type `<space>sh` then write `lazy.nvim-plugin`
  -- you can continue same window with `<space>sr` which resumes last telescope search
}, {
  ui = {
    -- If you are using a Nerd Font: set icons to an empty table which will use the
    -- default lazy.nvim defined Nerd Font icons, otherwise define a unicode icons table
    icons = vim.g.have_nerd_font and {} or {
      cmd = '⌘',
      config = '🛠',
      event = '📅',
      ft = '📂',
      init = '⚙',
      keys = '🗝',
      plugin = '🔌',
      runtime = '💻',
      require = '🌙',
      source = '📄',
      start = '🚀',
      task = '📌',
      lazy = '💤 ',
    },
  },
})

-- The line beneath this is called `modeline`. See `:help modeline`
-- vim: ts=2 sts=2 sw=2 et
</file>

<file path="LICENSE.md">
MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="projectBrief.md">
# Roo Code Memory Bank: Project Brief

**Maintain Project Context Across Sessions and Memory Resets for Consistent AI-Assisted Development**

This guide will walk you through using the Roo Code Memory Bank system. This powerful system, enhanced by Roo Code's built-in context-preserving features, provides a robust solution for managing project context across development sessions and seamlessly handling Roo's periodic memory resets.  By implementing the Memory Bank, you will ensure that Roo Code remains consistently informed about your project, leading to more effective and reliable AI-assisted coding.

**Understanding Roo Code's Built-in Context Features**

Recent updates to Roo Code incorporate built-in features designed to preserve context *within a single VS Code workspace session*. These are valuable enhancements to your workflow:

*   **Chat History Persistence:** Roo Code intelligently remembers your chat history within a VS Code workspace.  This means that if you close and reopen VS Code, or switch between files within the same project folder/workspace, your ongoing chat conversations are automatically restored, providing continuity within a session.
*   **Workspace Awareness:** Roo Code is now deeply aware of your VS Code workspace environment, including open files and the overall project structure. This allows it to understand the codebase more effectively and provide more contextually relevant and accurate responses during your development session.

**Key Point: Built-in Features Enhance, But Don't Replace, the Core Need for the Memory Bank**

While these built-in features significantly improve *in-session* context retention, they **do not eliminate** the fundamental need for the Roo Code Memory Bank. Roo Code still operates with periodic internal memory resets.  The Memory Bank system remains absolutely crucial for:

*   **Ensuring Persistence Across Roo's Memory Resets:**  Roo Code's internal memory can undergo resets even within an active VS Code session. The Memory Bank acts as your external, reliable long-term memory, guaranteeing context survival beyond these resets.
*   **Building Long-Term Project Knowledge:** The Memory Bank provides a structured, well-documented repository for capturing and organizing vital project knowledge. This includes architectural decisions, key technical context, design patterns, and ongoing progress tracking – going far beyond simple chat history to create a comprehensive project knowledge base.
*   **Establishing an Explicit Mode-Based Workflow:** The Memory Bank system defines clear and structured workflows for utilizing Roo Code's Architect, Code, and Ask modes. These workflows are specifically designed to actively manage and leverage project knowledge stored within the Memory Bank for each development phase.
*   **Implementing Project-Specific Rules with `.clinerules`:** The Memory Bank system uniquely incorporates `.clinerules` files. These powerful files allow you to define and consistently enforce project-specific rules and coding patterns, a capability that Roo Code's built-in features alone cannot provide.

**The Synergistic Power: Memory Bank and Roo Code's Built-in Features Working in Harmony**

Think of the relationship between the Memory Bank and Roo Code's built-in features this way:

*   **Roo Code's built-in features:** Provide valuable *short-term* and *workspace-level* context retention, enhancing the fluidity and convenience of your immediate coding session. They are like short-term memory enhancements for Roo.
*   **Memory Bank System:** Serves as Roo's *long-term* and *structured* persistent memory. It's your external, reliable "brain" for Roo, ensuring consistent project understanding that endures across sessions and memory resets, and providing a framework for organized project knowledge.

By using them together, you unlock a truly powerful and robust development workflow.
</file>

<file path="README.md">
# kickstart.nvim

## Introduction

A starting point for Neovim that is:

* Small
* Single-file
* Completely Documented

**NOT** a Neovim distribution, but instead a starting point for your configuration.

## Installation

### Install Neovim

Kickstart.nvim targets *only* the latest
['stable'](https://github.com/neovim/neovim/releases/tag/stable) and latest
['nightly'](https://github.com/neovim/neovim/releases/tag/nightly) of Neovim.
If you are experiencing issues, please make sure you have the latest versions.

### Install External Dependencies

External Requirements:
- Basic utils: `git`, `make`, `unzip`, C Compiler (`gcc`)
- [ripgrep](https://github.com/BurntSushi/ripgrep#installation)
- Clipboard tool (xclip/xsel/win32yank or other depending on the platform)
- A [Nerd Font](https://www.nerdfonts.com/): optional, provides various icons
  - if you have it set `vim.g.have_nerd_font` in `init.lua` to true
- Emoji fonts (Ubuntu only, and only if you want emoji!) `sudo apt install fonts-noto-color-emoji`
- Language Setup:
  - If you want to write Typescript, you need `npm`
  - If you want to write Golang, you will need `go`
  - etc.

> **NOTE**
> See [Install Recipes](#Install-Recipes) for additional Windows and Linux specific notes
> and quick install snippets

### Install Kickstart

> **NOTE**
> [Backup](#FAQ) your previous configuration (if any exists)

Neovim's configurations are located under the following paths, depending on your OS:

| OS | PATH |
| :- | :--- |
| Linux, MacOS | `$XDG_CONFIG_HOME/nvim`, `~/.config/nvim` |
| Windows (cmd)| `%localappdata%\nvim\` |
| Windows (powershell)| `$env:LOCALAPPDATA\nvim\` |

#### Recommended Step

[Fork](https://docs.github.com/en/get-started/quickstart/fork-a-repo) this repo
so that you have your own copy that you can modify, then install by cloning the
fork to your machine using one of the commands below, depending on your OS.

> **NOTE**
> Your fork's URL will be something like this:
> `https://github.com/<your_github_username>/kickstart.nvim.git`

You likely want to remove `lazy-lock.json` from your fork's `.gitignore` file
too - it's ignored in the kickstart repo to make maintenance easier, but it's
[recommended to track it in version control](https://lazy.folke.io/usage/lockfile).

#### Clone kickstart.nvim
> **NOTE**
> If following the recommended step above (i.e., forking the repo), replace
> `nvim-lua` with `<your_github_username>` in the commands below

<details><summary> Linux and Mac </summary>

```sh
git clone https://github.com/nvim-lua/kickstart.nvim.git "${XDG_CONFIG_HOME:-$HOME/.config}"/nvim
```

</details>

<details><summary> Windows </summary>

If you're using `cmd.exe`:

```
git clone https://github.com/nvim-lua/kickstart.nvim.git "%localappdata%\nvim"
```

If you're using `powershell.exe`

```
git clone https://github.com/nvim-lua/kickstart.nvim.git "${env:LOCALAPPDATA}\nvim"
```

</details>

### Post Installation

Start Neovim

```sh
nvim
```

That's it! Lazy will install all the plugins you have. Use `:Lazy` to view
the current plugin status. Hit `q` to close the window.

#### Read The Friendly Documentation

Read through the `init.lua` file in your configuration folder for more
information about extending and exploring Neovim. That also includes
examples of adding popularly requested plugins.

> [!NOTE]
> For more information about a particular plugin check its repository's documentation.


### Getting Started

[The Only Video You Need to Get Started with Neovim](https://youtu.be/m8C0Cq9Uv9o)

### FAQ

* What should I do if I already have a pre-existing Neovim configuration?
  * You should back it up and then delete all associated files.
  * This includes your existing init.lua and the Neovim files in `~/.local`
    which can be deleted with `rm -rf ~/.local/share/nvim/`
* Can I keep my existing configuration in parallel to kickstart?
  * Yes! You can use [NVIM_APPNAME](https://neovim.io/doc/user/starting.html#%24NVIM_APPNAME)`=nvim-NAME`
    to maintain multiple configurations. For example, you can install the kickstart
    configuration in `~/.config/nvim-kickstart` and create an alias:
    ```
    alias nvim-kickstart='NVIM_APPNAME="nvim-kickstart" nvim'
    ```
    When you run Neovim using `nvim-kickstart` alias it will use the alternative
    config directory and the matching local directory
    `~/.local/share/nvim-kickstart`. You can apply this approach to any Neovim
    distribution that you would like to try out.
* What if I want to "uninstall" this configuration:
  * See [lazy.nvim uninstall](https://lazy.folke.io/usage#-uninstalling) information
* Why is the kickstart `init.lua` a single file? Wouldn't it make sense to split it into multiple files?
  * The main purpose of kickstart is to serve as a teaching tool and a reference
    configuration that someone can easily use to `git clone` as a basis for their own.
    As you progress in learning Neovim and Lua, you might consider splitting `init.lua`
    into smaller parts. A fork of kickstart that does this while maintaining the
    same functionality is available here:
    * [kickstart-modular.nvim](https://github.com/dam9000/kickstart-modular.nvim)
  * Discussions on this topic can be found here:
    * [Restructure the configuration](https://github.com/nvim-lua/kickstart.nvim/issues/218)
    * [Reorganize init.lua into a multi-file setup](https://github.com/nvim-lua/kickstart.nvim/pull/473)

### Install Recipes

Below you can find OS specific install instructions for Neovim and dependencies.

After installing all the dependencies continue with the [Install Kickstart](#Install-Kickstart) step.

#### Windows Installation

<details><summary>Windows with Microsoft C++ Build Tools and CMake</summary>
Installation may require installing build tools and updating the run command for `telescope-fzf-native`

See `telescope-fzf-native` documentation for [more details](https://github.com/nvim-telescope/telescope-fzf-native.nvim#installation)

This requires:

- Install CMake and the Microsoft C++ Build Tools on Windows

```lua
{'nvim-telescope/telescope-fzf-native.nvim', build = 'cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release && cmake --build build --config Release && cmake --install build --prefix build' }
```
</details>
<details><summary>Windows with gcc/make using chocolatey</summary>
Alternatively, one can install gcc and make which don't require changing the config,
the easiest way is to use choco:

1. install [chocolatey](https://chocolatey.org/install)
either follow the instructions on the page or use winget,
run in cmd as **admin**:
```
winget install --accept-source-agreements chocolatey.chocolatey
```

2. install all requirements using choco, exit the previous cmd and
open a new one so that choco path is set, and run in cmd as **admin**:
```
choco install -y neovim git ripgrep wget fd unzip gzip mingw make
```
</details>
<details><summary>WSL (Windows Subsystem for Linux)</summary>

```
wsl --install
wsl
sudo add-apt-repository ppa:neovim-ppa/unstable -y
sudo apt update
sudo apt install make gcc ripgrep unzip git xclip neovim
```
</details>

#### Linux Install
<details><summary>Ubuntu Install Steps</summary>

```
sudo add-apt-repository ppa:neovim-ppa/unstable -y
sudo apt update
sudo apt install make gcc ripgrep unzip git xclip neovim
```
</details>
<details><summary>Debian Install Steps</summary>

```
sudo apt update
sudo apt install make gcc ripgrep unzip git xclip curl

# Now we install nvim
curl -LO https://github.com/neovim/neovim/releases/latest/download/nvim-linux-x86_64.tar.gz
sudo rm -rf /opt/nvim-linux-x86_64
sudo mkdir -p /opt/nvim-linux-x86_64
sudo chmod a+rX /opt/nvim-linux-x86_64
sudo tar -C /opt -xzf nvim-linux-x86_64.tar.gz

# make it available in /usr/local/bin, distro installs to /usr/bin
sudo ln -sf /opt/nvim-linux-x86_64/bin/nvim /usr/local/bin/
```
</details>
<details><summary>Fedora Install Steps</summary>

```
sudo dnf install -y gcc make git ripgrep fd-find unzip neovim
```
</details>

<details><summary>Arch Install Steps</summary>

```
sudo pacman -S --noconfirm --needed gcc make git ripgrep fd unzip neovim
```
</details>
</file>

<file path="updates.md">
# Progress Log

## 2025-03-04: New Test Mode

- Added Test mode configuration (.clinerules-test)
- Added Test mode to .roomodes
- Configured Test mode permissions and capabilities
- Set up Test mode collaboration workflows
- Defined Test mode triggers for mode switching

## 2025-02-09: Intelligent Mode Switching Implementation

### Completed (2025-02-09 22:19)
1. **Enhanced Mode Switching System**
   - Implemented comprehensive intent-based triggers
   - Added bi-directional switching between all modes
   - Integrated context preservation mechanism
   - Updated all .clinerules files with new configuration

2. **Documentation Updates**
   - Enhanced developer-primer.md with new mode switching details
   - Updated mode-switching-spec.md with latest capabilities
   - Added new mermaid diagrams for mode transitions
   - Improved configuration examples and trigger documentation

3. **Memory Bank Updates**
   - Updated activeContext.md with current progress
   - Added new decision log entry in decisionLog.md
   - Enhanced progress tracking in this file
   - Maintained comprehensive cross-referencing

### Latest Features
1. **Intent-Based Triggers**
   - Code mode: implement, create, build, debug, test
   - Architect mode: design, structure, plan, organize
   - Ask mode: explain, help, what, how, why

2. **Operational Improvements**
   - Context preservation across mode switches
   - File-based and mode-specific triggers
   - Capability-based mode transitions
   - Simplified configuration structure

### Next Steps
1. **Testing and Validation**
   - Test intent-based trigger effectiveness
   - Validate context preservation
   - Monitor mode transition accuracy
   - Measure workflow efficiency

2. **Future Enhancements**
   - Consider adding more specialized triggers
   - Explore machine learning for trigger refinement
   - Implement transition analytics
   - Gather user feedback

### Known Issues
- Need to validate trigger comprehensiveness
- Performance impact of context preservation to be measured


This document tracks the progress of the Roo Code Memory Bank project.

## Work Done

### February 9, 2025 - Memory Bank File Handling Improvements
- Revised Memory Bank file handling approach:
  - Defined four core Memory Bank files
  - Removed specific filename searches from .clinerules
  - Implemented more flexible Memory Bank detection
  - Moved projectBrief.md to project root
  - Added user prompts for creating missing core files
- Updated documentation to reflect new Memory Bank structure
- Improved support for existing projects with different file organizations

### February 9, 2025 - Enhanced Roo Mode Behaviors
- Created comprehensive mode configuration files (.clinerules-*) for all three modes
- Added explicit instructions for Memory Bank initialization and usage
- Implemented consistent behavior across modes:
  - Immediate reading of all Memory Bank files on activation
  - Restricted use of attempt_completion directive
  - Added task presentation based on Memory Bank content
  - Improved user interaction flow
- Added detailed UMB (Update Memory Bank) procedures for each mode

### Previous Work
- Created and populated initial Memory Bank structure
- Implemented basic Memory Bank detection and initialization
- Developed initial mode-specific rules and responsibilities
- Created documentation framework
- Resolved various tool-related issues and bugs

### Completed in Current Session (2025-02-09)

#### Mode Definition Improvements
- Completely revised role definitions for all three modes:
  - Architect: Strategic leader for system design and documentation
  - Code: Implementation-focused developer
  - Ask: Knowledge assistant and documentation analyzer
- Added explicit responsibilities and collaboration patterns
- Clarified file authority for each mode

#### Memory Bank System Enhancements
- Standardized Memory Bank detection process across all modes
- Added explicit tool calling syntax in rules
- Implemented clear mode-specific responses to Memory Bank states
- Improved status prefix handling (`[MEMORY BANK: ACTIVE/INACTIVE]`)

#### Rule File Updates
- Updated all `.clinerules-xxx` files with improved structure
- Added standardized Memory Bank detection procedures
- Clarified mode collaboration patterns
- Enhanced UMB process documentation

## Current Status

Mode definitions and Memory Bank management rules have been significantly improved. The system is ready for testing with the new rules to verify improved reliability and clarity in mode interactions. Next step is to test the revised system with Roo to validate the changes.
</file>

</files>
